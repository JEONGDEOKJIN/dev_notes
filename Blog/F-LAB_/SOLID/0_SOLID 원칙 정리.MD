# SOLID 원칙 정리 

## 이 글의 목표 

## 요약 

```
- SOLID 원칙은 '관심사 분리(모듈 및 인터페이스)', '모듈의 유연성(해당 모듈을 사용할 때)', 'testability' 에 기여한다. 
```


## 관련 개념 

### 아래 개념들에 관심을 갖게 된 이유 
```bash
- 각각의 solid 원칙이 '코드 레벨' 로 구현되었을 때, 사실, 코드 수정 한번으로 바뀌는 것도 아니고, 다양한 코드를 수정한다. 

- DIP, OCP 예시 코드를 봤을 때, 되긴 되는데, '그래서 어쩌라는 거지?' 라는 생각이 든다. 이걸, 아래의 개념으로 보면, 응용에 도움이 될 것 같았다. 

- 그래서, 예시 코드를 볼 때, '어떤 지점이 아래 개념들을 구현하는데 기여하는 걸까?' 라는 관점에서 보면 좀 더 도움이 될 것 같았다. (#⭐⭐⭐⭐⭐)

- 각 원칙이 달성되기 위한 '세부 핵심 요소' 를 파악하면, 내 코드에 응용할 때, '최소한 이 세부 핵심 요소이 달성된 의존성 역전 법칙을 만들자.' 라는 생각을 하면 응용이 좀 더 쉽지 않을까 하는 생각에 작성.
```


### Separation of Concerns (관심사의 분리) 

```
- 의의 
    - '모듈' 이 갖는 관심사(맡은 책임) 이 '분리' 되어야 한다. 

- 주요 활용 
    - SRP(단일책임원칙), ISP(인터페이스 분리 원칙)
```
<br/>

### Modular Reusability & Flexibility (모듈화, 모듈 재사용성, 모듈 유연성)

```
- 의의
    - '코드' 를 '작은 단위(모듈)' 로 나눔 
    - 나눈다고 끝이 아니라, '나눈것을 사용할 때 쉽게 사용' 하는 것을 의미 
    - '사용' 한다는 게, '단순 이식' 도 있지만, '기능이 추가 되었을 때 testability 를 해치지 않으면서, 유연하게 확장' 되어야 하는 경우도 있음. 

- 주요 활용 
    - 모듈화 : OCP 
    - 모듈 유연성 : OCP, DIP (#⭐⭐ 기능 추가에 유연하게 대응한다는 관점)
```
<br />

### Encapsulation (캡슐화)

```
- 의의 
    - 객체 내부 '상태(데이터)' 와 '로직(메서드)' 을 필요한 부분만 공개

- 효용 
    - 특정 기능 수정에 따라서, 예기치 못 한 에러가 발생하는 side effect 발생이 적음

- 주요 활용 
    - SRP, ISP

CF. 관심사 분리를 통해 달성될 수 있는 성질이 아닐까 싶음
```
<br />

### Abstraction (추상화)

```bash
- 의의 
    - 핵심 기능만 노출하고 세부 사항을 감춘다. 

- 특징 
    - 인터페이스나 추상 클래스를 통해 구체적인 구현에 대한 의존성을 줄입니다. (#📛📛📛 이해가 필요)

- 궁금한 것 
    - 근데, 이게, 캡슐화랑 겹치는거 아니야? (#❓❓❓)

- 주요 활용 : DIP, OCP
```
<br />


### Testability (테스트 용이성)
```bash
- 의의 
    - '테스트 하기 쉬운 구조' 를 만들기 

- 주요 활용 
    - SRP, DIP (#📛📛 아직 왜 이게 기여하는지 잘 모르겠음.)

CF. 아직, '테스트 하기 쉬운 코드' 가 뭔지 모르겠음 (#📛📛📛 공부가 필요해)
```

<br />

## Single responsibility principle (SRP)

1. 코드를 보고, 모듈 간의 관계도를 그림으로 계속 연상하자.
![Image](https://i.imgur.com/Jr9Ro21.png)

2. '`동사 + 명사` 형태로 된 모듈 이름으로 추측할 수 있는 기능' 여부 
```
추측할 수 없으면 -> '분리' 를 해서 -> 별도의 모듈(모듈화) 로 만든다.
참고 : F-LAB\SOLID\1_단일책임원칙_코드예제.MD
```

3. '다른 곳에 재사용 할 것 인지 여부' 
```
다른 곳에 범용적으로 사용할 것 같으면 -> '분리' 를 해서 -> 별도의 모듈(모듈화) 로 만든다.
참고 : F-LAB\SOLID\1_단일책임원칙_코드예제.MD  
```

4. 'UI 데이터 바인딩 컴포넌트' 와 '이벤트 수집 및 핸들러 컴포넌트' 는 분리한다. (Container-Presenter Pattern)
```
참고 : F-LAB\응집도, 결합도\참고자료.md
```

<br />

## Open/closed principle (OCP)

1. '기능이 추가' 되어야 하는 상황이 핵심 

2. '기능 추가의 방법' 으로써 1) '원본 코드를 수정' 하는게 아니라 2) 상속 같은 extend 를 쓰고 3) react 컴포넌트에서는 children 응 사용

3. Hoc 를 사용하기도 하는데, 이 부분은 좀 더 공부가 필요해 

<br />

## Liskov Substitution Principle (LSP)
- 패스 

## Interface Segregation Principle (ISP)
- 인터페이스 차원에서의 관심사 분리라고 생각. 

<br />

## Dependency Inversion Principle (DIP)

1. '상위 모듈' 이 '하위 모듈의 구체적인 구현' 에 '의존' 하지 않는다. 

```js
- 여기에서 '상위 모듈' 이 무엇이고, '하위 모듈' 은 '사람의 인지적인 개념' 이다. 
    ex) '알림 서비스' vs 'email, sms' 는 상하 관계다. 알림 서비스 중 email, 과 sms 의 다양한 방식이 있을 수 있기 때문. 

- '구체적 구현에 의존' 한다는 건, 상위 모듈 안에서, 하위 모듈 클래스를 실행시킨다는 것을 의미. 
    ex) 
    // 상위 모듈: 알림 서비스
        class NotificationService {
        private emailSender: EmailSender;

        constructor() {
            this.emailSender = new EmailSender(); // EmailSender에 직접 의존
        }

        notify(message: string) {
            this.emailSender.send(message);
        }
        }

```

2. '상위 모듈' 이 **추상화(인터페이스)** 에 의존하도록 한다. 


3. '상위 모듈' 은 직접적으로 emailSender, SMSSender 와 같은 구체적 구현을 알 필요가 없다. (#📛📛📛 대체 왜 😢😢😢 이건 class 문법에 익숙하지 않아서 그런 것 같다!!)




<br />


# 추가 공부할 것 
- class 문법 익숙하게 만들기


<br/>

# 출처 
- f-lab 아티클 : https://bit.ly/3YROtqb