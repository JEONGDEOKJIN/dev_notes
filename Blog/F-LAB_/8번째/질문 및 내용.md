
# [질문1] 복수의 api 로부터 fetch 를 해올 때의 데이터 흐름을 어떻게 관리할 것 인가 

## 내가 테스트 해본 흐름 
```
[요구사항] 
1. 각각 다른 3개의 api 주소로 부터 데이터를 수신 

2. 각 탭은 세부 항목이 비슷하거나 다름 
- 주요 항목 : 주문상품, 취소사유, 결제정보, 주문 배송지, 송장번호
- 여기에서 1~2개씩 다름 

3. 동일한 '교환 사유' 여도, 요구하는 필드가 다름 

[생각해본 방식] 
1. 해당 PAGE 에서 필요한 데이터를 interface 타입으로 만듦 
2. interface 와 api 데이터를 넣으면 -> interface 에 맞게 데이터를 변환하는 함수를 만듦 
3. PAGE 에서 필요로 하는 데이터 형식으로 return 
4. 컴포넌트 ui 에서는 객체 구조분해 할당으로 데이터를 꽂아주기만 하면 됨
5. 이렇게 될 경우 
	1) 다양한 api 소스를 바인딩 할 수 있고 
	2) 로직과 ui 를 분리해서 진행할 수 있지 않나 하는 생각
```
![Image](https://i.imgur.com/XePULNo.jpeg)

![Image](https://i.imgur.com/wDTXcHa.jpeg)

![Image](https://i.imgur.com/iEDvPXX.jpeg)

![Image](https://i.imgur.com/4pxupoz.jpeg)

### 수정해야 할 부분 
```
- useBindingHook 에서 type 을 지정해주기
```

<br/>


## 디벨롭을 어떻게 할 것 인가

![Image](https://i.imgur.com/UkgJ6Z7.jpeg)

### 1. PAGE 스키마 작성 
```bash
심리학, 컴퓨터 공학을 봤을 때,'스키마'에서 발견되는 키워드는 '구조' (출처 : https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%82%A4%EB%A7%88)

'구조' 란 '필드' 와 '그에 대응하는 값' 이 매칭되어 있는 상태라고 볼 수 있음. 

그래서, 'page 스키마를 작성한다.' 라는 건, '각 페이지의 필드' 와 '각 필드에 대한 값 또는 타입' 을 기재하는 것으로 볼 수 있음. 

현재 프론트는 typescript 를 작성하므로, 결국, '페이지에 대한 타입 설정' 이 해당 스키마가 된다. 
```

- 스키마 작성에 있어 '상위호환' 과 '하위호환' (#compatibility #호환성 #⭐⭐⭐)
```
- '상위 호환' : 앞으로 새롭게 기능이 추가되어도, 문제가 없도록, 구현.  
- '하위 호환' 
    : 기존에 잘 작동하고 있는 것을 포함해서, 기능을 만듦.

- 이 개념은 '컴포넌트 작성', 'API versioning' 등을 하는데에도 적용이 된다. 

```


- 추가적으로 스키마에 대한 지식 
```
[schema 의 종류]
- json, yaml, avro, gRPC, 

[gRPC 의 쓰임] 
- 서버 <-> 서버 : GRPC 라는 프로토콜을 사용. 
- Rest api 에 비해서 속도가 더 빠름. 왜냐면, rest api 는 '어떤 형태로 보내주겠다' 라는 걸, 미리 스키마를 구성하고 작업 함. (#서로 어떤 형태로 주고 받을지 안다.) 
CF. 프엔 <-> 서버 : REST API 를 사용 

[schema 의 종류가 구분되는 이유] 
- serialize 와 deserialize 방식에 있어 차이가 나서, json, yaml, avro, gRPC 등의 종류로 세분화 되는 것. 
- typescript 를 쓰는 프론트엔드 관점에서, type 설정이 스키마 작업이 되는 것. 

[스키마의 특징] 
- avro는 '상위호환' 을 보장

```

### 2. 



# 추천 알고리즘 

```
- collaborative filtering
- cold start problem
- b2b 추천 시스템 회사 : Recombee
- 엔지니어링 난이도 : 추천을 잘 했다의 기준이 애매 -> so, 난이도가 있음 
```

# TTS
```


```



# SSR

```
'병렬성', '동시성' 을 잘 쓰는 프론트엔드 엔지니어링 
event loop utils, cpu utils 


Hydration 
    - 클릭 하면 -> 이동하는 버튼을 구성하는 건 1) ui + 2) js (이동 이벤트)
    - 애초에는 js + html 이 붙은 상태로 보내려고 함 
    
    - 그러다가 
        1) 서버는 HTML 을 보낸다. -> 브라우저는 브라우저 자원을 써서 렌더링 한다.
        2) 서버는 JS 를 보낸다. -> 이건, 네트워크 자원이 사용됨 (#그래서, 브라우저가 UI 를 렌더링 하는 것과 동시에 지원이 가능하다.)
        3) JS 가 도착하면, ATTACH 를 해준다. 

    - 무조건, HYDRATION 이 좋나? 
        1) 매우 간단한 JS 가 있을 수 있음 
        2) 그랬을 때, 'HYDRATION 을 관리하는 과정' VS 'HYDRATION 을 했을 때의 효과(좀 더, 기다리지 않고, 빨리 UI 먼저 보여주고, JS 하게 하는 느낌)'


```



# CF. '압축' 에 대해서 
```
- 압축의 종류 (compression)
    - lossy compression (데이터의 손실을 허용하는 compression)
        - 일부 데이터에 대해서는 좀 더 덜 신경쓰는
        - 속도가 빨라짐
    - compression (zip, tar.gz)
    - png, jpeg, svg….
        - compression 방식에서 차이가 있음.
        - 속도에 따라서
    - 취지 : `유저 반응` 을 중요하게 생각하는 곳들은 
        1) jpeg 로 보내고 
        2) png 로 변경하기도 함 (#⭐⭐⭐⭐⭐⭐⭐) 
        (#ex: 유튜브 1080p vs 780p )
```



<br/>

# 생각해볼 것 및 TODO

- '상위 호환'과 '하위호환' 의 개념을 고려한 구현이 컴퓨터 공학에서는 '클린 코드' 라고 할 수 있을 것 같다는? 
    - 즉, 새롭게 기능이 추가되어도, 빠르게 대응할 수 있는 상태를 지향하는 것 

- FEATURE STORE IMPLEMENT 관련 자료 전달주신 것 읽기 
- DATA 자료 전달주신거 읽기
- SSR 작성하고 시도 하기 

- 프로젝트는 한번에 완성된 걸 하는게 아니라, 하나씩 해나가는 느낌으로 진행하자. 
```
1. 간단한 RAG 을 사용한 프로그램을 만들자. 
    : 이건, 아마도, 그러면서, 누적치를 쌓아나가자. (#⭐⭐ 무조건, 한달에 하나는 만들어나가야 한다. 그 정도의 SMALL 프로젝트)
    : 그러면서 나의 생산성을 체크하고, '성장 cycle' 을 만들어나가야 한다. 

2. 그 다음에, TTS 등을 사용한, 것들 까지 나아가자 
```