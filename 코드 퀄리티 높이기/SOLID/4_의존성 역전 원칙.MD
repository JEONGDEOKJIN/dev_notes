# **D: Dependency inversion principle (의존성 역전 원칙)**

# **Description**

The Dependency Inversion Principle states that high-level modules should not depend on low-level modules, but rather on abstractions. Secondly, abstraction should not depend on details. When you think about it, this sounds like common sense. Practically, though, we might miss these details when we work on our software architecture.

# **The Challenge**

We will again take into consideration our Logger example for this scenario. The Dependency Inversion Principle isn’t as obvious during implementation as the other principles.

In this example, consider an `errorDecorator` The above scenario works fine as long as you don't need to switch to a different logger in the near future. But let's say you do — for better compatibility, pricing, etc. The immediate solution then would be to simply use a `RedisLog` class instead of `GrayLog`. But the `RedisLog` implementation is probably different from that of `GrayLog` - perhaps it uses the `sendLog` function instead of `saveLog` and accepts a string parameter instead of an object param.

Then we change its implementation to input as a string.

```ts
class RedisLog {
  sendLog(logMessage: string) {
    console.log(`Log Sent to Redis for logMessage`);
  }
}

const errorDecorator = (error: Error, ..) => {
  log.sendLog(JSON.stringify(error));
};

const main = () => {
  errorDecorator(new Error("Error Message"), RedisLog());
};

main();
```

Now, the above case is a simple one with 2 minor changes — the method name and its parameters. But practically, there might be a number of changes with functions added/removed and parameters modified. This isn’t an ideal approach, since this would affect a number of code changes at the implementation level.

택시: RedisLog / 택시기사: errorDecorator

택시 회사 (택시기사한테 택시를 할당해주는 외부): Main

택시 기사는 택시 회사한테 택시라는 의존성을 주입받아서 사용함

# **Solution**

Going a little deeper, we see that the issue arises because our `errorDecorator` function (which can be a class too) depends on the low-level implementation details of `Loggers` available. *We now know that the Dependency Inversion principle recommends relying on high-level abstractions instead of low-level implementation details.*

So, let’s create an abstract module instead which should be the dependency of our `errorDecorator` function:

```
abstract class LoggerService {
  createLog: (logObject: object) => void;
}
```

That’s it — the LoggerService takes a log object in its createLog function, and this can be implemented by any external logger API. For GrayLogwe can use GrayLoggerService, for RedisLogcreate a RedisLoggerServiceimplementation and so on.

```
class GrayLoggerService implements LoggerService {
  createLog(logObject: object) {
    const grayLog = new GrayLog();
    grayLog.saveLog(logObject);
  }
}

class RedisLoggerService implements LoggerService {
  createLog(logObject: object) {
    const logMessage = JSON.stringify(logObject);
    const redisLog = new RedisLog();
    redisLog.sendLog(logMessage);
  }
}
```

Instead of changing multiple implementation details, we have our separate LoggerServices which can be injected into the errorDecorator function.


```ts
const errorDecorator = (error: Error, loggerService: LoggerService) => {
  loggerService.createLog(error);
};

const main = () => {
  errorDecorator(new Error("Error Message"), new RedisLoggerService());
};

main();
```

In the above solution, you can see that the errorDecorator is not dependent on any low-level implementation modules such as `GrayLog` or `RedisLog` but is completely decoupled from the implementation. Additionally, by adhering to this we implicitly follow the Open/Closed principle since it is open to extension and closed to modification.

# **Summary**

The Dependency Inversion principle is probably the most critical of all the SOLID principles. This is because it’s not an obvious choice at first to abstract out the Service layers that are needed for low-level implementations. The idea, usually, is to look at low-level implementations first and then work backward to generalization, instead of the other way around.

Do check Dependency Injection, Adapter Pattern, Service Locator Pattern, etc.- these are implementations of the Dependency Inversion Principle itself.