# **I: Interface segregation principle (인터페이스 분리 법칙)**

# **Description**

The Interface Segregation Principle — or ISP for short — states that instead of a generalized interface for a class, it is better to use separate segregated interfaces with smaller functionalities. This is similar to ideas we’ve discussed so far around maintaining loose coupling, but for interfaces.

### The Challenge

Consider our previous example of `PaymentProvider`. This time, imagine that the `PaymentProvider` is an interface that is implemented by `CreditCardPaymentProvider` and `WalletPaymentProvider`.


```ts
interface PaymentProvider {
  validate: () => boolean;
  getPaymentCommission: () => number;
  processPayment: () => string;
  verifyPayment: () => boolean;
}
```

Let’s implement the interface PaymentProvider for our CreditCartPaymentProvider class. The credit card provider does not provide an API to verify payment individually, but since we’re implementing PaymentProvider, we are required to implement the verifyPayment method, otherwise, the class implementation will throw an error.

```ts
class CreditCardPaymentProvider implements PaymentProvider {
  validate() {
    // Payment is validated
    console.log("Payment Card Validated");
    return true;
  }
  getPaymentCommission() {
    // Commission is returned
    return 10;
  }
  processPayment() {
    // Payment processed
    console.log("Payment Processed");
    return "Payment Fingerprint";
  }
  verifyPayment() {
    // No verify Payment API exist
    // Return false to just implement the Payment Provider
    return false;
  }
}
```

Now suppose the wallet providers do not have a validate API, to implement PaymentProvider for WalletPaymentProvider. In this case, we must create a validate method — which does nothing as can be seen below:

```ts
class WalletPaymentProvider implements PaymentProvider {
  validate() {
    // No validate method exists
    // Just for sake of implementation return false
    return false;
  }
  getPaymentCommission() {
    // Commission is returned
    return 5;
  }
  processPayment() {
    // Payment processed
    console.log("Payment Processed");
    return "Payment Fingerprint";
  }
  verifyPayment() {
    // Payment verification does exist on Wallet Payment Provider
    console.log("Payment Verified");
    return false;
  }
}
```

# **Where This Fails**

The above implementation works fine but seeing the fake implementations, we know this is a **code smell **that would quickly become an issue with a number of such fake implementations popping up throughout the code.

# **Solution**

The above scenario can be fixed using the interface segregation principle. Firstly, we need to take a look at our interface rather than its implementation and see if it can be refactored to decouple various constituents of the `PaymentProvider` interface.

```
interface PaymentProvider {
  getPaymentCommission: () => number;
  processPayment: () => string;
}

interface PaymentValidator {
  validate: () => boolean;
}

interface PaymentVerifier {
  verifyPayment: () => boolean;
}
```

We now have three interfaces instead of one and each implementation can be decoupled further. Since the `CreditCardPaymentProvider` does not have any `verifyPayment` method, we can simply implement:

1. PaymentProvider, and
2. PaymentValidator

```
class CreditCardPaymentProvider implements PaymentProvider, PaymentValidator {
  validate() {
    // Payment is validated
    console.log("Payment Card Validated");
    return true;
  }
  getPaymentCommission() {
    // Commission is returned
    return 10;
  }
  processPayment() {
    // Payment processed
    console.log("Payment Processed");
    return "Payment Fingerprint";
  }
}
```

Similarly, the `WalletPaymentProvider` is also fixed with the class now implementing:

1. PaymentProvider interface, and
2. PaymentValidator interface

```
class WalletPaymentProvider implements PaymentProvider, PaymentVerifier {
  getPaymentCommission() {
    // Commission is returned
    return 5;
  }
  processPayment() {
    // Payment processed
    console.log("Payment Processed");
    return "Payment Fingerprint";
  }
  verifyPayment() {
    // Payment verification
    console.log("Payment Verified");
    return false;
  }
}
```

Finally, the cohesion issues and fake implementations are gone, and we’ve achieved the desired result using interface segregation.

# **Summary**

Interface Segregation is one of my favorite design principles. In simple words, it proposes to split large interfaces into smaller ones with a specific purpose. This provides loose coupling, better management of code, and easier usability of code.

A key idea to grasp is composition over inheritance. This might not be well supported by legacy designs but is substantially important for modern software architecture.