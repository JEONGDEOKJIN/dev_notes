# 내용 정리

### clean code

- 의의
    - `낮은 결합도` 와 `높은 응집도` → `모듈화` 가 잘 되어 있는 상태
    - SOLID 원칙이 대체로 잘 지켜진 코드
- 효과 (필요성)
    - 유지보수, 재사용성이 높음
    - 원치 않는 side effect 가 적어짐? (#❓❓ 왜냐면, 결합도가 낮기 때문에, 특정 기능이 다른 기능에 미치는 영향이 적음 → 그래서, 하나가 잘못되면, 그냥, 거기만 격리되어서 문제가 되고, 거기만 잘 고치면 됨)

### 모노레포

- 연관 개념
    - 응집도, 결합도, 모듈화 (#❓❓❓ 이 모노레포 라는 개념이 왜 응집도, 결합도에서 나온거지?

- 의의
    - `동일한 언어`
    - 각각의 다른 repo 들이 있음
    - 각 repo 간 `공통 코드`가 있음

- 방법
    - monerepo
        - turborepo (monorepo lib)
    - git submodule (#✅ 공통 컴포넌트는, 이걸로 관리할 수 있지 않을까.)
        
        
        - git submodule
            - 레포지 토리를 합치지 않고 dependency 를 관리
            - a repo 에서 b repo 를 사용하는 중 (A REPO ← B REPO)
                - `gitsubmoduleels`
                    - `git submodul init`
                - 다양한 브랜치가 있을 것
                    - 해당 해시의 코드를 받을 수 있음
                - 다른 레포지토리의 코드를 다운 해서 받을 수 있음

- [적용시 고려해야 할 것] ‘코드가 동일하다.’ 라고 해서, 무조건 묶는 것이 좋은가?
    - (반례) 코드가 동일하다고 해도, 묶는 것이 안 좋은 경우
        
        ```jsx
        코드가 동일해도, 각 서비스가 많이 바뀔 수 있음. 
        
        a repo, b repo 모두, 1-dependency 를 참고 하고 있음. 
        
        a repo 에서, 1-dependency 를 변경하고 싶음. 
        그랬을 때, b repo 에도 영향을 미치는 것 임 
        ```
        
    
    - [생각해 볼 것] 이런 느낌은 ‘공통 css’ 도 마찬가지 라는 생각이 듦
        
        ```jsx
        
        - 그러면, A -> B 의 관계에서, 혹은 B <- A 의 관계에서, 
        '사전 실행' 의 관점(DAG 관점) 에서 
        
        - '사용하는 곳' 이라는 키워드 (#⭐⭐⭐⭐⭐⭐) 의 관점에서 봤을 때, 
        	- 사용하는 곳에서 필요해서 고쳤는데, 다른 곳에도 영향을 미친다, 라는 이슈!!!
        	
        - 그러면, '분리' 를 어떤 기준으로 해야 하나? 
        	- CSS 에서의 분리는 뭐지? 
        ```
        

- [질문] 모노레포라는 개념이 왜 `응집도`, `결합도`와 관련된 개념이지?
    - 모노레포로 관리한다는 건, ‘결합도가 높아지는 것’ 왜냐면, 내부에 있던 코드를 외부에서 가져오는 것 이기 때문에. (#❓  맞나)

- 질문
    - “module, yarn, 을 사용하는 이유도 `dependency 를 관리` 하기 위해서“ 라고 하셨는데, `dependency 를 관리` 한다는 건
        - `DAG` 그래프를 통해 `순차적 실행` 되어야 하는 요소의 관계를 파악
        - npm module, yarn 이 해주는 건
            1. 라이브러리 간 dependency 를 DAG 를 통해 관리 
            2. 특정 라이브러리가 업데이트 되면, 그걸 잘 반영하는 역할? 

- CF. DAG : 1) ‘순차적으로 실행’ 되어야 하는 것의 관계를 파악 하는데 도움 되는 graph 2) 라이브러리의 사전 실행시 필요한 공통 라이브러리의 관계를 정리
    
    부모노드는 항상, CHILD 방향으로 EDGE 가 형성됨 
    
    - 이 DAG 구조에 기반하는 컴퓨터 프로그래밍 구조가 많음
        - 컴파일러
        - ALIRFLOW, KUBERFLOW
            - cron job : 주기적인 알람. 숫자값을 설정하면, 매일 주기적으로 울림
            - 주기적인 프로그램을 실행시키는 도구
            - 매일 아침 9시
                - 주기적으로 push 보내려고 할 때 ⭐⭐⭐⭐⭐⭐
                - 이건 cron 문법
                    
                    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0cae17fc-ff5c-424e-96d6-f2bfc4d7beb4/a169ce13-0b55-4ea1-a93f-a8936d1a82ea/image.png)
                    
                
            - push
                - 클라우드에서 cron job 설정 가능
            
            - ariflow 할 때
                - 작업을 순차적으로 실행해야 하는 경우가 있음 (#⭐⭐⭐⭐⭐⭐⭐⭐⭐)
        - 순차 실행의 예시
            - 배포 프로세스
                - 코드 → 코드 로컬에서 돌려본다. (반드시 이전 작업이 완료되어야 되는 경우⭐⭐⭐⭐⭐⭐⭐)
                - (위의 것과 병렬적으로) 팀원분들께서 리뷰를 남긴다.
            - DAG 는 `사전 실행` 되어야 하는 것의 관계
                
                ```bash
                처음엔 4개만 실행됨 
                
                ```
                
                ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0cae17fc-ff5c-424e-96d6-f2bfc4d7beb4/66678aee-c5bd-4d70-8fc4-ffce4a6b1930/image.png)
                
        
        ```bash
        CRON 은 작업 순서를 할 수 없음 
        
        작업 순서를 관리 할 수 있는게 CRON JOB 
        ```
        
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0cae17fc-ff5c-424e-96d6-f2bfc4d7beb4/545f027e-d33b-4937-8860-f29ec9c8802f/image.png)
    

- DAG 에서 파생된 flux 관련 궁금증 : 1) 아키텍처 관점 뿐 아니라 하나의 클래스 (service, api 등 전체 흐름의 중간 카테고리 등에서도) , 코드, 관점에서 DAG 가 어떻게 이루어지는가를 알아야 함
    - DAG 를 보니, `flux` 패턴이 생각남
    - 그러면, 이 flux 패턴에서 보이는 `granph` 가 `DAG` 의 일종이 맞는건가 (#❓❓❓)
    - store 관리 (클라이언트 데이터 관리) 에 있어 `flux 패턴`
        - 요즘엔 잘 사용 안 함
        - 왜냐면, redux 가 사장된 거랑 비슷하게, 하나만 변경해도 다른 코드들도 변경해야 해서
        - 단방향 vs 양방향
            - 단방향
                - 관리 편해
                - dependency 를 cycle 형태로 관리하면, 실수할 일이 적어
    - 시사점
        - 전체 아키텍처(?) 레벨이 아니라, 하나의 함수, 하나의 repo 관점에서, 어떻게 작동하는가를 DAG 로 그릴 수 있음.
        - 이것을 어떻게 운영하는가를 고민해야 함.
        - 지금 맥락에서는 ‘graph 에 따라서, 작동 순서가 있고, 이 작동 순서에 따라서 파악하는 과정’ 이 내 코드에는 없었어. 이걸 또한 가져가야 한다는 거 (#⭐⭐⭐⭐⭐ 이게 아키텍처 레벨의 고민인가?)
    

### 응집도와 결합도

- 이 그림 또한, `DAG` 처럼 그래프 라고 생각하면 되려나? → 맞다면, 모든 코드블록에서, 각 기능을 이렇게 시각화 해볼 수 있겠네 ⭐⭐⭐
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0cae17fc-ff5c-424e-96d6-f2bfc4d7beb4/ca0a963a-030c-4eb5-9a33-ff21c637a8cc/image.png)
    

- 결합도 의의
    - ‘모듈 간’ 의 의존성
        - 의존이 강하면 → 변경이 어렵고
            - 만약, UserService 같은게 100개 있다고 해보자 (#😢😢😢 근데, 변경이 어렵다는 예시가 와닿지가 않아 😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢)
            - 모듈과 모듈이 연결될 수 밖에 없어.
                - 다만, 전체가 퐁당 들어가냐, 아니면, return 데이터 하나만 들어가냐의 차이 인가?
                - 고친다고 할 때, 공수 고려? 음… (이건 와닿지가 않아 아직)
        - 의존이 낮으면 → `독립성` 이 높아짐 (#⭐⭐⭐⭐⭐⭐⭐⭐ 이 느낌이 결합도를 낮춘 예시라는 것을 알아야 함 )

- 높은 결합도 예시 : 1) 외부 클래스가 바로 들어왔다. 2) 외부 클래스에서 오류가 난 건지, 내부 코드 블록에서 오류가 난건지 모르는 현상이 발생한다. 3)
    - UserService 의 구현이 변경되면, UserProfile 도 변경되어야 한다. ( #왜❓❓ 다르게 코드가 나와도, 결국, UserProfile 이 조금 바뀌어야 하는 건 동일하지 않나?)
    
    ```jsx
     import UserService from './services/UserService';
    
    const UserProfile = () => {
      const user = UserService.getUser(); // UserService에 강하게 결합
    
      return (
        <div>
          <h1>{user.name}</h1>
          <p>{user.email}</p>
        </div>
      );
    };
    
    export default UserProfile;
    ```
    

- 결합도 낮춘 예시 1) `외부에서 들어오는 건, return 된 결과값 만!` 들어온다. 클래스 전체가 들어오지 않는다. 2) 그러면, 하나의 소스(UserService) 뿐 아니라, 다양한 클래스(서비스, 소스) 에서 온 데이터를 처리할 수 있게 된다.
    
    ```jsx
    // UserProfile이 UserService를 props로 받도록 개선
    interface User {
      name: string;
      email: string;
    }
    
    interface UserProfileProps {
      user: User;
    }
    
    const UserProfile = ({ user }: UserProfileProps) => (
      <div>
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
    );
    
    export default UserProfile;
    
    // UserService에서 데이터를 가져오는 로직을 분리
    
    import UserProfile from './UserProfile';
    import UserService from './services/UserService';
    
    const App = () => {
      const user = UserService.getUser(); // 여기서만 UserService에 의존
    
      return <UserProfile user={user} />;
    };
    
    export default App;
    
    ```
    

- 응집도 의의
    - 모듈 내 기능 간 밀접도
- 응집도가 낮은 예시
    - 하나의 모듈(컴포넌트, 함수, 클래스)  에서 `여러 책임` 을 다루는 경우 (#❓ 모듈이라고 하는 건, 컴포넌트, 함수 클래스를 다 포괄하는 말 인가?)
    - `이름(동사 + 명사)` 를 보았을 때, `모든 코드가 설명` 되는 경우는, 휴리스틱 적으로(사용 경험상) 응집도가 높음.
    - 즉, 동일한 기능을 담당하는 것 끼리 모여 있으면, 응집도가 높은거고, 그렇지 않으면, 응집도가 낮다.
    - 그럼, 동일한 기능을 담당한다는 건?
        - 결국, 하나의 모듈 이름과 해당 코드들이, 매칭 되는 걸 의미.
    

### solid 원칙

- 단일 책임 원칙
    
    
    - 하나의 모듈(함수, 클래스, 컴포넌트) 에서, `하나의 책임`(역할) 만 하게
    
    - [이슈] 그러면, 어디까지를 하나의 역할(책임) 으로 봐야 하는가.
        - 관련 이슈 : 오버 엔지니어링
        - 원칙 : 분리할 수 있으면 싹다 하는게 좋긴 함
            - 다만, 오버 엔지니어링
        - 절충안
            - `분리를 해도 재사용이 높을 것` 같지 않으면 → 분리 안 한다.
            - 코드를 이해하는데 그리 어렵지 않으면 → 분리를 안 한다.
            - `네이밍` 이 설명하는 것과, `실제 코드` 가 가리키는 것이 일치될 수록 좋은 코드. 그것에 벗어나지 않게 분리한다.
            - `테스트 코드` 를 짤 때, 분리 하는 경우, 테스트 coverage 가 더 높아지는 경우가 있음. 그래서 테스트 코드를 짜는게 하나의 기준이 될 수 있음. ( #😢😢😢 실제로 테스트 코드를 짜는게 지금 내 현실에서는 불가능 한데…)
            - 많이 짜봐야 함 → 그러면, `좋은 코드` 는 어떻게 분리를 했는가의 관점에서 봐야 하고 → 참고할 수 있는게
                - 멘토님 깃헙 코드
                    
                    
                    - 멘토님 레포지토리 보는 팁 (#📛📛📛 근데 이런 흐름이 아키텍처 인가???????????????? 이렇게 디렉토리 별로 어떤 역할을 하는가를 설명하는게?)
                        
                        
                        - view(page / blocks(페이지 끼리의 공통 요소 , 로직이 있는 뷰/ element (스타일만 있는 것) ) →  hook(이렇게 가공된 걸, store 에 넣는, 데이터를 직접 관리, 꺼내오는)  → service (백엔드 서버에서 받아오는거 , 필터링 된 데이터를 가공하는 로직, a랑 b 를 합쳐서 뭔가를 만드는거, 데이터를 가공하는 거 ) → repository (api 에서 받아온 것 중에서, 필요한 거랑 , 없는게 있음, 필요한 것만 필터링 하는 역할) → api (네트워크 관련된거 핸들링, error handleing, retry 요청, 마이크로프론트엔드 형태? , network 관련된 모든 요청, cache)
                - 오픈 소스 컨트리뷰션 ( #⭐⭐⭐ 텐케이 만개, 되는 start)
            - DDD 에서 도메인을 분리
                - EX) `응집도` 와 `결합도` 를 `시각화` 하고 → 이걸 코드로 짠다 (#😢😢😢😢😢) (#📛📛📛 아직 이해가 안 돼. 적용도 아직 안 돼)
            
        - 의존성 분리가 안 된 것
            - 해당 클래스 안에 가지고 오는 것
        - 의존성 분리가 잘 된 것
            - main 에서 해당 인스턴스가 생성될 때 넣어주는 거
            - 그러면, 에러로그로 어떤 것 이든, 넣을 수 있음 (#⭐⭐⭐⭐⭐⭐⭐⭐ 이게 분리가 잘 되었을 때, 어떤 모듈이건 간에, 분리가 잘 되면 나오는 효과 같은데)
        

- 분리 팁 (#⭐⭐⭐⭐⭐)
    - 로직의 경우, 사용하다가, 반복이 되면, 분리하는게
    - css 는 공통 컴포넌트를 먼저 잡고 가는