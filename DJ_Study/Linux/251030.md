### 컴퓨터의 네가지 핵심 부품

- 컴퓨터의 네가지 핵심 부품의 큰 그림
    
    ![image.png](attachment:6a7d96b2-dcc4-4481-941e-369bfa7cca24:image.png)
    
- 컴퓨터는 `명령어`를 `처리` 하는 기계
    
    ```jsx
    '명령어' 는 컴퓨터를 실질적으로 '움직이는' 정보
    '데이터' 는 명령어를 위한 '재료'
    
    ```
    
    ![image.png](attachment:61ec32f9-c27e-4f8a-a4fd-d4d134eb0f89:image.png)
    
- `메모리` : 프로그램이 실행되려면, 메모리에 데이터가 저장되어야 한다. 실행되는 프로그램(프로세스) 의 메모리를 저장한다.
    
    ```jsx
    - 현재 실행되고 있는 프로그램(프로세스) 의 명령어와 데이터를 저장하는 부품
    - '어떤 프로그램이 실행' 되기 위해서는 프로그램을 이루는 명령어, 데이터가 메모리 안에 있어야 한다. 
    - 실행되지 않는 프로그램은 '보조기억장치' 에 저장되어야 한다. 
    ```
    
    ![image.png](attachment:a2382c2a-30f3-4284-8ad6-7bf31b1f38a5:image.png)
    
    ```jsx
    메모리 내에, 어떤 '위치'에 '저장(특정)' 했는지를 파악하기 위해 '주소' 를 사용
    
    '주소' 가 있기 때문에 -> 내가 원하는 데이터가 어디에 있는지를 알 수 있다. 
    ```
    
    ![image.png](attachment:e265fc49-c9bf-43a8-8ec8-369a9ac4f797:image.png)
    
    ![image.png](attachment:bdc98341-cb5b-4a96-9e4e-b88b713bf718:image.png)
    
- `cpu` : 1) 제어 2) ‘명령어를 읽고 - 실행’
    
    ```jsx
    명령어를 읽고 - 해석 - 실행 
    
    제어장치 : 1) 제어 신호 2) 명령어 해석 기능 
    
    [첫번째 명령어] 
    1. 제어장치는, '제어신호' 를 내보내서, '1번째 메모리' 에 있는 '명령어'를 읽는다.
    
    2. 메모리가 1번지에 있는 명령어를 CPU 의 레지스터(임시저장) 에 갖다준다. 
    
    3. 제어장치는 '명령어 해석 기능' 이 있으니까, 해당 명령어를 해석하고 -> 3,4번지 에 저장된 데이터가 필요하겠구나 라고 판단해서 -> 3,4 번지 메모리 '읽기 신호'('제어신호') 를 보낸다. 
    
    4. 메모리가 3, 4번지에 있는 명령어를 데이터를 레지스터(임시저장) 에 갖다준다. 
    
    5. 제어장치는 ALU 에게 명령 : ALU 는 3,4번지를 더하고 -> 더한 결과를 레지스터에 저장한다. 
    
    [두번째 명령어] 
    6. 제어장치는, '제어신호' 를 내보내서, '2번째 신호' 를 읽는다.
    	- 메모리가 2번지에 있는 명령어를 CPU 의 레지스터(임시저장) 에 갖다준다. 
    	- 제어장치는 '명령어 해석 기능' 이 있으니까, 해당 명령어를 해석하고 -> "계산된 결과를 메모리에 저장해야 겠구나." 라고 판단. -> 5 번지 메모리 '쓰기 신호'('제어신호') 를 보낸다. 
    
    ```
    
    ![image.png](attachment:bc6f2a34-afb3-4404-a531-cc39cbb7042c:image.png)
    
    ![image.png](attachment:7e11f170-a320-4de7-a1a1-3f0391422478:image.png)
    
    ![image.png](attachment:c4caa0ce-74c7-4a70-baa6-1f0c29be87c8:image.png)
    
    ![image.png](attachment:04c09aa7-bc2d-4ce7-aa86-c0355bdf65a6:image.png)
    
    ![image.png](attachment:f4485edf-e7d5-4807-812e-40c4e811f21e:image.png)
    
    ![image.png](attachment:c4826aa5-b901-48a5-b01f-9b861371c882:image.png)
    
    ![image.png](attachment:faabf9ac-9b40-4dfb-8692-bc3583626bb4:image.png)
    
    ![image.png](attachment:0cfc5e58-fa73-4fd6-a441-ca40b07b5e28:image.png)
    
    ![image.png](attachment:08e40d0a-e925-424e-987b-dabdae137db3:image.png)
    
    ![image.png](attachment:04d090c6-07e0-47a8-9e9b-dc61c57d5957:image.png)
    
- `보조기억장치` : 전원이 꺼져도 기억할 수 있는 부품
    
    ```jsx
    메모리는 '전원이 꺼지면(공급되지 않으면)' => 휘발된다. 
    보조기억장치 : 전원이 꺼져도 저장될 수 있는 장치
    ```
    
    ![image.png](attachment:70bd0a27-e9ac-450f-963a-c9a5d8bdd3b3:image.png)
    
    ![image.png](attachment:bb8d4642-5127-41f6-88d2-173b8e522067:image.png)
    
- `입출력장치` : 컴퓨터 ‘외부’ 와 연결되어서 컴퓨터 ‘내부와 정보 교환’ 할 수 있는 부품
    
    ```jsx
    컴퓨터 '외부' 와 연결되어서 
    컴퓨터 '내부' 와 '정보를 교환' 할 수 있는 부품
    ```
    
    ![image.png](attachment:4e88c817-83ae-4b51-99bd-0f3e9028cae4:image.png)
    
- `메인보드` : 4가지 부품이 연결되는 곳. 각 데이터가 `버스` 를 통해 주고 받음
    
    ![image.png](attachment:18d96713-5c7f-4c90-95dd-60934632ea75:image.png)
    
    ![image.png](attachment:1a58f27b-c80f-48e7-8c3e-ee94cf326f2b:image.png)
    

### 운영체제(operating system) : 프로그램이 실행되기 위해 필요한 ‘자원’ 을 할당하고 ‘관리’ 하는 ‘프로그램’ (#✅ 설명해보기 #📛 한번에는 안 될 것 임)

```jsx
1. 모든 프로그램은 실행되기 위해 '자원' 을 필요로 한다. 

'자원' 이란, 컴퓨터가 실행될 때 마땅히 필요한 '요소'
	-> 이 요소에는 1) '컴퓨터의 4가지 핵심 부품' 2)  '파일', '패킷' 등도 포함 

'운영체제' 란
	- 프로그램이 실행되기 위해서 필요한 '자원' 을 할당, 
	- 올바르게 실행되도록 '관리' 하는 ex) 프로세스 간 자원을 간섭하지 못 하게 관리, 엉뚱한 프로그램이 실행되지 않도록 관리
	- 특별한 '프로그램' 
	
CF. 운영체제도 '프로그램' 이므로 -> 실행이 되면 -> 메모리에 적재 됨 -> 운영체제가 적대되는 공간이 메모리 공간 중 '커널' 이 적재 

2. 어떻게 관리? 어떤 관리? 
	메모리 관리 
		 - 프로그램이 실행되면 -> 너 메모리 필요하지? 3000번지 가서 실행해 라고 할당 
		 - 프로그램이 종료되면 -> 너 종료 했지? -> 3000번지 메모리 제거할게
	
	cpu 관리 
			- 우리눈은 '동시 실행' 되는 것 처럼 보임 -> 그런데 사실은 cpu가 빠르게 계산해서 '순차 실행' 임 
			- 어떤 순서대로, 언제까지 실행되게 를 판단하는 게 OS 가 결정
			
	입출력 장치 관리 
			- 메모장.txt 가 프린트를 쓰고 있음 -> 근데 워드 가 쓰려고 해 -> "하나 밖에 못 쓸 때, 너 가만히 있어! 이놈이 쓰고 있어!" 라고 제어함
			
			
3. 만약, 이 운영체제 없이 프로그램을 개발한다면? 
	-> 개발자가, 하드웨어까지 컨트롤 하는 코드를 작성해야 한다는 말 
			EX) 언제 메모리를 할당하고, 언제 CPU 를 동작 시키고 등등
			
	-> 운영체제 덕분에, 하드웨어에 조작하는 코드를 직접 할 필요 없음
			EX) 운영 체제가 제공해주는 걸 쓰면 됨 ex) printf

4. 이러한 관점에서 운영체제는 
	개발자가 하드웨어를 컨트롤 할 수 있게 해주는 '연결다리' 역할 

```

![image.png](attachment:f2691542-5e03-4c09-944b-2ca171f8a2a9:image.png)

![image.png](attachment:06ccdaff-59bc-40bc-9a57-d3d18a0fa379:image.png)

![image.png](attachment:b3f69d3c-58df-4bdc-a388-0de1147d6bc7:image.png)

![image.png](attachment:5c6b357c-2ef1-48a4-9084-bf2bd6bf4919:image.png)

![image.png](attachment:44e50a3a-c0d2-4bce-9e4a-667bdff53db6:image.png)

![image.png](attachment:90830210-2584-4295-b067-070b2097b44d:image.png)

![image.png](attachment:e9fb6e1f-5f49-4fb6-a39b-cffd52cbe1a4:image.png)

### 운영 체제의 종류와 리눅스, 우분투를 배우는 이유 : 시장점유율

- 운영체제의 종류
    
    ```jsx
    운영체제 (Operating System) 종류 
    │
    ├── Windows (마이크로소프트)
    ├── Linux (오픈소스)
    ├── macOS (애플)
    ├── Unix (역사적 OS, Linux의 조상)
    ├── Android (구글, 모바일용)
    ├── iOS (애플, 모바일용)
    └── 기타 (FreeBSD, Solaris 등)
    
    👉 그 중 리눅스에 대해서 배울 것 임 -> 왜?
    
    1. 클라우드 인프라의 90%가 리눅스 EX) AWS, 구글 등  
    	👉 AWS 서비스 이용하여 서비스를 제공하려면, 리눅스를 다룰 수 있어야 함 (#⭐⭐⭐⭐⭐⭐)
    	
    	CF. 클라우드 서버 OS 점유율:
    	Linux        90%  ██████████████████████████████
    	Windows       8%  ███
    	기타          2%  █
    	
    	CF. 주요 클라우드 플랫폼:
    	├── AWS (Amazon Web Services)     → Linux 기본
    	├── Google Cloud Platform         → Linux 기본
    	├── Microsoft Azure               → Linux 지원 (Windows보다 많이 사용됨!)
    	├── DigitalOcean                  → Linux 전용
    	└── Heroku, Vercel 등             → Linux 기반
    		
    
    - 리눅스 기반으로 작성된 다양한 OS 들이 있음 
    
    - 그중 우분투는 
    	1) 시장지배력 : 2024년 기준  33.9% (#aws 친화적)
    	2) 다양한 학습 레퍼런스 
    	
    SO, 우분투 OS 에서 사용되는 문법을 배우는 것 임. 리눅스 중 CentOS 같은 OS 를 사용하면 명령어가 조금 다를 수 있음. 
    	
    ```
    
- 사진 자료
    
    ![image.png](attachment:2a3b88f2-9202-49b1-bbb9-2912c256f92f:image.png)
    

- 리눅스를 익혀야 하는 이유 : 클라우드 인프라의 기본
    
    ```jsx
    1. 클라우드 인프라의 90%가 리눅스 EX) AWS, 구글 등  
    	👉 AWS 서비스 이용하여 서비스를 제공하려면, 리눅스를 다룰 수 있어야 함 (#⭐⭐⭐⭐⭐⭐)
    	
    	CF. 클라우드 서버 OS 점유율:
    	Linux        90%  ██████████████████████████████
    	Windows       8%  ███
    	기타          2%  █
    	
    	CF. 주요 클라우드 플랫폼:
    	├── AWS (Amazon Web Services)     → Linux 기본
    	├── Google Cloud Platform         → Linux 기본
    	├── Microsoft Azure               → Linux 지원 (Windows보다 많이 사용됨!)
    	├── DigitalOcean                  → Linux 전용
    	└── Heroku, Vercel 등             → Linux 기반
    ```
    

- 우분투 익혀야 하는 이유 : 리눅스 기반 OS 중 가장 범용적 + 학습 레퍼런스
    
    ```jsx
    - 리눅스 기반으로 작성된 다양한 OS 들이 있음 
    
    - 그중 우분투는 
    	1) 시장지배력 : 2024년 기준  33.9% (#aws 친화적)
    	2) 다양한 학습 레퍼런스 
    	
    SO, 우분투 OS 에서 사용되는 문법을 배우는 것 임. 리눅스 중 CentOS 같은 OS 를 사용하면 명령어가 조금 다를 수 있음. 
    ```
    

### [Ubuntu 실습] WSL 설치 (#window 환경만 설치하기!)

- 참고 자료 (#⭐⭐⭐)
    
    https://www.youtube.com/watch?v=jJa7LujM8PY
    
    https://wikidocs.net/219899#google_vignette
    

```jsx
WSL (window subsystem linux) 
	- 윈도우에서, 가상머신 없이 리눅스 실행

```

- [1] 설치 하기
    - 참고자료 보고 진행 (#⭐⭐⭐)
    
    - 윈도우에서 설치 이후에는 Ubuntu 를 설치 해야 하는데, 이때는 LTS 버전을 설치하면 됨
    
    ![image.png](attachment:9ddb1f34-50f3-4d87-a6ef-66b0fb0ae682:image.png)
    
- [2] 설치 후 실행하기
    - `WSL` 을 검색해서 → 실행 하면 됨
    
    ![image.png](attachment:1290b12b-7ca3-4e5b-8af8-affb4119bf88:image.png)
    
- CF. 실행이 안 되는 경우
    
    ```jsx
    컴퓨터 사양으로 설치가 안 되는 경우가 있을 수 있음!  
    ```
    

### 첫 화면 해석하기 : 사용자 이름@호스트:루트디렉토리$입력가능!

- `deokjin@DESKTOP-LHQ5S8E:~$` 해석하기
    
    ```jsx
    deokjin@DESKTOP-LHQ5S8E:~$ 해석하기
    
    [deokjin : '사용자 이름 자리' ]
    - 여러 사용자를 만들 수 있음 -> 지정하지 않으면, 디폴트로 ubuntu 로 지정됨
    - WSL 사용할 때, userName 설정했을 때 들어감.
    - 현재 로그인한 사용자 이름
    
    [@: at (어디에서)]
    - 어떤 호스트에서? 라는 질문
    
    [DESKTOP-LHQ5S8E : 'host이름' 자리] 
    - DESKTOP-LHQ5S8E: 컴퓨터(호스트) 이름
    CF. '설정 → 시스템 → 정보' 에서 확인
    
    [:~ 현재 위치] 
    	- ~는 '홈 디렉토리' 를 의미 
    	CF. pwd를 치면 '/home/deokjin' 이 나옴 
    	
    
    [$: 일반 사용자 프롬프트]
    	- 명령어를 입력할 수 있는 상태! 를 의미
    	- 관리자는 #로 표시됨
    
    	
    [결론] 
    	deokjin '일반사용자' 가 
    	DESKTOP-LHQ5S8E 컴퓨터의 
    	홈 디렉토리에서 
    	명령어 입력 대기 중" 
    ```
    
    ![image.png](attachment:bf5c8dfc-162f-4942-9c2b-7d2e3148216e:image.png)
    
    ![image.png](attachment:394a1376-1921-4690-86e7-fe13cfadf32c:image.png)
    
    ![cd hello → hello 디렉토리로 이동한 경우 ‘~’ 이 아니라 hello 디렉토리로 기재됨](attachment:b99e72eb-8597-4425-9b8c-34e9cb8b0044:image.png)
    
    cd hello → hello 디렉토리로 이동한 경우 ‘~’ 이 아니라 hello 디렉토리로 기재됨
    

### 기본 조작법 : 작업줄 이동, 작업 취소, 복사 붙여넣기

```jsx
[기본 조작법] 

- 기존 에디터와 동일 : 막 입력 -> 엔터, 백스페이스, 띄어쓰기 

- 단어단위 이동 옵션 : 1) 방향키 2) cntrl or alt 이동키 (space 바 간격을 이동할 수 있음) 

- 작업 취소(해당 줄을 한번에 취소하는 것) : cntrl c 
		CF. ^C : ^는 cntrl 을 눌렀다! 라는 의미 
		
- 터미널 화면 깔끔하게 지우기 : clear

- 복사 & 붙여넣기 
	: 윈도우 
		1) (복사하기)ctrl insert / (붙여넣기)shift insert 
		2) (설정 변경 후) ctrl + shift + c/v 
	: 맥 : cntrl c / v 

```

- 📢 [윈도우] 복사 붙여넣기 잘 안 되면 : 속성 → 옵션 → ctrl + shift + c/v 클릭
    
    ![image.png](attachment:aac17283-fa3b-499c-a084-a5178f7c71ec:image.png)
    
    ![image.png](attachment:a0111723-ce1b-49a4-9e16-ffcfd58961a8:image.png)
    

### **디렉터리(directory) 의미 : 폴더와 같은 개념! 결국, 파일(file)**

```jsx
- 윈도우 환경에서 '폴더' 를 리눅스에서는 '디렉토리' 라고 부름 
		-> 같은 개념인데, 이름만 다르게! 부름

- 모든것이 '파일' 
	: 파일도 파일 
	: 디렉토리도 파일	
```

> 변수 이름은 `testFile`, `testDir` 이렇게 바로 떠오르는 이름으로 짓기
> 

### 경로 확인 후 디렉토리 이동 : 1) `pwd → cd` 2) `cd ..`

```bash
- '경로' : 특정 '파일' 이 어디에 있는지를 설명하는 주소

[경로확인] 
pwd 
	: print wordking directory
	: 현재 디렉토리 경로 
 
[디렉토리 이동] 
cd '디렉토리 이름'
	: change directory
	: 디렉토리 이동
	
[상대적 이동] 
cd ..
	: 상위 디렉토리로 이동
	: 더 이상 이동하지 못 하면 'Root 디렉토리'

[Root 디렉토리]
	- 리눅스 '최상단' 에 있는 디렉토리 
	- '~' 로 표현됨 
	- cd .. : 더 이상 이동하지 않음
	
[경로 표현] 
	- 디렉토리가 '계층적' 으로 구성되어 있음 -> 이 계층을 '/' 슬래시로 표현
```

 

- 루트 디렉토리와 경로 표현 (#✅ 그림 그려야)
    
    ![image.png](attachment:68afaa34-59a1-43f1-b87f-f763ca6fb27c:image.png)
    

### 해당 디렉토리 내부 파일 조회 : `ls`, `ls-l`, `ls-a` (#파일 종류 확인, 숨김 파일 조회)

```bash
[경로확인] 
ls 
	: list
	: 현재 디렉토리 경로 	
	
📢 root 에서 'var > log'로 이동해보기
	deokjin@DESKTOP-LHQ5S8E:/$ cd var/

[cd btmp 가 안 되는 이유? ]
	- cd 는 change directory 의 약자 -> so, '파일' 에 대해서 cd 를 못 함 
	- 그러면, 딱 봤을 때, '파일 vs 디렉토리' 구분은? 
	
	
[파일 종류 확인] 
ls -l
	: ls 대시 l
	: list option longFormat(자세한 정보)
	
	CF. - : 대시, option (세부 옵션을 제공)
	
	CF. 구분
		첫 글자 d : 디렉토리(directory) 
		첫 글자 - : 파일(file)
		
		
[숨김파일 조회] 
ls -a
		: list option all
	: . 으로 시작하는 파일은 숨김처리 함 ex) `.env` `.gitignore` 등 
	
📢 root 디렉토리로 이동 > 숨김파일 조회 하기(`ls -a`) vs ls 비교 
	: ls 로 안 보이던 파일이 ls -a 로 조회가능함! 
	 

```

- 📢 파일 종류 확인
    
    ![image.png](attachment:95b198fb-8656-4e0a-b66b-093510c83e13:image.png)
    

### 옵션(option) : long/short option,  여러 옵션 함께 사용하기, 명령어 마다 고유한 옵션

```bash
1. short option, long option 
	- short option : 하이픈 1개, 약어
		ls -l 
		
	- long option : : 하이픈 2개, full name
		ls --list
		
2. 여러 옵션을 같이 쓸 수 있다. 
		2.1) 다른 명령어와 함께 
			ls -l -a
			
			CF. 순서가 바뀌어도 무방함 
				ls -l -a === ls -a -l
				
		2.2) long/short option을 함께
			ls -l -all
		
		2.3) short option 을 한꺼번에 쓸 수 있음. 
			ls -l -all === ls -la === ls -al 

3. 명령어 마다 다르다.
		`ls -l -a` 는 ls 만의 옵션 
		`mkdir -l -a` 이 작동한다는 보장이 없음
```

- 추가 기능은 ‘공식문서’ 에서 확인 가능 : 📁 [링크](https://man7.org/linux/man-pages/man1/ls.1.html)

### 상대경로, 절대경로 : `/` 로 시작하는지 여부 (# `.` = 현재 디렉토리. `..` = 상위 디렉토리 )

```bash
[ '/' 여부에 따라서, 이동 가능 여부가 달라짐 ] 

(ex) '/var/log' 에 있는 상태에서 'log' 디렉토리로 가려면?) 
	cd log #🔵 이동 가능
	cd /log # 📛 이동 불가

왜❓❓❓❓❓  
	👉 '경로' 가 '/' 로 시작하면 -> 무조건 '절대 경로' 임 
	👉 '/' 이외에 모두 '상대경로' 임 ex) 'cd ./', 'cd ../', 'cd hello' 

[절대경로 예시] 
cd /hello
	: 루트디렉토리(/) 에서 ls 를 했을 때 존재하는 hello 디렉토리에 접근
	: 'root > hello' 에 위치하는 디렉토리에 접근

[상대경로 예시] 
cd hello 
	: '/' 로 시작하지 않기 때문에 상대 경로
	: 현재 디렉토리에서, hello 디렉토리로 접근
	: cd ./hello 와 동일

cd ./hello
	: '/' 로 시작하지 않기 때문에 상대 경로
	: 현재 디렉토리(.) 에서, hello 디렉토리로 접근 (#⭐ '.' : 현재 디렉토리)
	: cd hello 와 동일
	
cd ../hello
	: '/' 로 시작하지 않기 때문에 상대 경로
	: 상위 디렉토리(..)에서, hello 디렉토리로 접근 (#⭐ '..' : 상위 디렉토리)

```

![image.png](attachment:211a108f-8e61-4c6f-8cbe-9e82d928003b:image.png)

### `~` 의 의미와, 빠르게 홈 디렉토리로 이동하기 : `~` === ‘홈 디렉토리’ === /home/{사용자이름} (feat: 루트 디렉토리와 홈 디렉토리의 구분)

```bash
[컴퓨터 'userName' 설정과 '홈 디렉토리']
하나의 컴퓨터를 '여러 사용자' 가 사용할 수 있음. 
각각의 사용자는 'userName' 을 설정해서 사용함. 
각 userName 에게 할당된 디렉토리가 '홈 디렉토리' 이다. 
'홈 디렉토리' 의 경로는 `/home/{사용자이름}` 이다. 
CF. `/home` 을 들어가보면, 생성되어 있는 userName들을 알 수 있다. 

[홈디렉토리 경로 표현]
1. 전체 이름 표현 : '/home/deokjin' 전체 경로를 표현할 수 있음.
	: deokjin@DESKTOP-LHQ5S8E:/home/deokjin$
	
2. 약어 사용 : '~' 
	: deokjin@DESKTOP-LHQ5S8E:~$
	: pwd 를 통해 확인 할 수 있음.

[루트 디렉토리 vs 홈 디렉토리의 개념] 
- 루트 디렉토리 : 더 이상 부모가 없는, 프로젝트의 최상단 
- 홈 디렉토리 : 해당 userName 에게 할당된 디렉토리. 최상단에서 2depth 내려옴
	
[ '~' vs '/' ] 
	- '/' 
		: 최상단 '루트 디렉토리'
		: cd /
	
	- '~' 
		: 내 userName 에 부여된 '홈 디렉토리'
		: cd ~

=== [TODO] ===
📢 루트 디렉토리에서 > cd home/{사용자명} '홈 디렉토리'로 이동해보기 
		-> 'home/{사용자명}' 이 '~' 로 변화하는 것 확인해보기! 
		-> 해당 경로에서 pwd 를 쳐서 확인해보기
		-> '홈 디렉토리' === 'home/{사용자명}' === '~' 인 것 인지하기!!!  
```

> 여기 부터 얼마나 걸릴 까 1시 ~
> 

### 파일 및 디렉토리 생성 및 제거 :  `touch`, `mkdir`, `rm`

- 일반 파일 생성 : `touch [파일명]`

```bash
# [📢 실습] 
$ cd ~ #홈 디렉토리 이동
$ cd pwd #원하는 이동을 했는지 경로 확인

$ touch hello #파일 생성
$ ls #파일 확인
```

- 디렉토리 생성
    - `mkdir [디렉토리명]`
    - `mkdir` = make directory

```bash
# [📢 실습] 
$ cd ~ #홈 디렉토리 이동
$ mkdir hello #원하는 디렉토리 생성

$ touch hello #파일 생성
$ ls -l #현재 디렉토리 파일 조회(ls) + 세부 정보(-l)
```

- 파일 삭제
    - `rm [파일명]`

```bash
# [📢 실습] 
$ ls #삭제할 파일 확인
$ rm test.txt #원하는 파일 제거
$ ls #잘 삭제되었는지 확인
```

- 디렉토리 삭제
    - `rm -r [디렉토리명]`
    - `-r` : `-recursive` 디렉터리 내부 파일 까지 삭제

```bash
# [📢 실습] 
$ ls #삭제할 디렉토리 확인
$ rm -r hello #원하는 디렉토리 제거
$ ls #잘 삭제되었는지 확인
```

- 파일 또는 디렉토리 삭제
    - `rm -r [디렉토리명 or 파일명]`
    - `-r` : `-recursive` 디렉터리 내부 파일 까지 삭제 (# `-r` 로, 파일 삭제도 가능함)
    - `-f` : 강제 삭제 (권한이 없는 경우에도 강제 삭제가 가능) (#편의상 추가하여 사용)

```bash
# [📢 실습] 
$ touch testFile  #테스트 파일 생성
$ mkdir testDirectory  #테스트 디렉토리 생성

$ rm -rf testFile  #테스트용 파일 제거
$ rm -rf testDirectory  #테스트용 디렉토리 제거

$ ls #잘 삭제되었는지 확인
```

### 파일 및 디렉토리 복사/ 이동 / 이름 변경 :  `cp`, `mv`

- 파일 복사 : `cp [복사할 파일] [복사할 위치 or 복사할 파일명]`

```bash
# [📢 실습] 
$ cd ~ #홈 디렉토리 이동
$ cd pwd #원하는 이동을 했는지 경로 확인

$ mkdir testCP  #디렉토리 생성
$ touch testCPFile  #파일 생성

# 1️⃣ [상대경로] 홈 디렉토리에 있는 'testCPFile' 파일을 'testCP' 디렉토리로 이동
$ cp testCPFile ./testCP
# 잘 복사 되었는지 확인 
$ cd testCP
$ ls

# 2️⃣ [상대경로] 'testCP' 로 작동하는지 확인
$ rm -rf testCPFile #저장한 파일 제거
$ cd ~ #홈 디렉토리 이동
$ cp testCPFile testCP #⭐'testCP' 로 작동하는지 확인
# 잘 복사 되었는지 확인 
$ cd testCP
$ ls

# 2️⃣ [절대경로] 사용해서 복사하기 
$ rm -rf testCPFile #저장한 파일 제거
$ cd ~ #홈 디렉토리 이동
$ cp testCPFile /home/deokjin/testCP
# 잘 복사 되었는지 확인 
$ cd testCP
$ ls
```

- 디렉토리 복사 : `cp -r [복사할 디렉토리] [복사할 위치 or 복사할 디렉토리명]`

```bash
# [📢 실습] 
$ cd ~ #홈 디렉토리 이동
$ cd pwd #원하는 이동을 했는지 경로 확인

#testDir 복사해서 testDir2 로 만들기
$ cp -r testDir testDir2   

# 잘 복사 되었는지 확인 
$ ls
```

- 디렉토리 및 파일 이동 : `mv [이동할 파일] [이동할 위치]`

```bash
# [📢 실습] 
$ cd ~ #홈 디렉토리 이동
$ cd pwd #원하는 이동을 했는지 경로 확인

#moveFile & moveDir을 testDir로 이동
$ mv moveFile testDir  #파일 이동
$ mv moveDir testDir   #폴더 이동

# 잘 반영 되었는지 확인 
$ cd testDir
$ ls
```

- 디렉토리 및 파일 이름 변경 : `mv [이름 바꿀 파일] [변경할 파일명]`

```bash
# [📢 실습] 
$ cd ~ #홈 디렉토리 이동
$ cd pwd #원하는 이동을 했는지 경로 확인

# 파일 또는 디렉토리 이름 변경
$ mv testDir testChangeDir
$ mv testFile testChangeFile

# 잘 반영 되었는지 확인 
$ ls
```

### 간편한 기능 : 자동완성, 이전에 사용한 명령어 불러오기  (# `tab` , ⬆, ⬇)

- 자동완성 : 앞에 몇 글자 적고 → `tab` 누르기

```bash
# [📢 실습] 
$ cd ~ #홈 디렉토리 이동
$ cd pwd #원하는 이동을 했는지 경로 확인

$ touch longName123123123123  # 긴 파일 이름 생성

$ rm -rf l # 까지 작성하고 -> tab 누르기 (#⭐⭐)
```

- 기존 사용했던 명령어

```bash
대기 상태에서 
'화살표 ⬆' or '화살표 ⬇' 를 클릭. 

기존에 사용한 명령어가 나옴
```

> 여기 부터 얼마나 걸릴 까 3시 ~
>