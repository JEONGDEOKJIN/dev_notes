# 평가와 실행

### 

| 구분 | ECMAScript 스펙 용어 | 블로그/튜토리얼 | 역할 | 초기화 |
| --- | --- | --- | --- | --- |
| 1단계 | Declaration Instantiation | 생성단계
평가단계 | - 실행 컨텍스트 생성 
- 식별자 등록
(= 메모리 공간을 준비한다.)
(=Environment Record에 식별자를 바인딩(등록) 한다.) | - var 의 경우 undefined 값을 할당하여 초기화 진행(원시타입 중 undefined 을 할당 → so, 콘솔 찍으면 undefined 가 찍힘)

- let, const 의 경우, 초기화된 값 설정하지 않음 → <uninitialized> 상태 (#내부적으로는 <the_hole> 이 저장됨 |
| 2단계 | Evaluation | 실행단계 | 코드 실행 |  |
- let, const 의 경우 : `<unInitialized>` 상태에서의 평가와 실행, 그리고 `TDZ`
    
    ```jsx
    console.log(x);
    let x = 10;
    
    [평가단계]
    	// 메모리에 특정한 마커값(<the hole>)이 초기에 저장되긴 함 
    	// 해당 마커값을 읽고 -> js엔진은 초기화가 안 되었다! 해당 변수가 <unInitialized> 상태라고 판단 
    	// <unInitialized> 상태이므로, 접근해도 값을 가져오지 못 하는 TDZ 상태 
    		 Environment Record:
    			{
    			  x: <the hole>  // 마커 값
    			}
    	
    [실행 단계]
    - '<unInitialized> 상태' 인 경우 
    	1) 할당 전에 접근하면 'unInitialized 에러' 를 발생 
    			console.log(x)
    			let x = 10;
    	
    	2) 할당을 하게 되면 
    		// let x = 10; 실행
    			{
    			  x: 10          // ← (메모리 내부에서는) <the hole>을 10으로 교체
    			}
    						
    ```
    
    ```jsx
    let x = 10;
    
    // === Declaration Instantiation 단계 ===
    Environment Record:
    {
      x: <the_hole>  // V8의 경우
      // 또는
      x: <uninitialized>  // 스펙의 추상적 표현
    }
    
    // 실제 메모리:
    // - 메모리 공간 자체는 할당됨 ✅
    // - 특별한 내부 마커 값이 저장됨 ✅
    // - JavaScript 코드로는 접근 불가능한 값 ✅
    
    // === Evaluation 단계 ===
    {
      x: 10  // 정상 값으로 교체
    }
    ```
    

아래 코드가 JS 엔진에 의해서 ‘평가 → 실행’ 되는 과정 따라가기

```jsx
var x = 10;
function foo() {
  var y = 20;
  console.log(x + y);
}
foo();
```

```jsx
1) 평가 단계 (#Creation Phase #생성 단계)
    → 실행 컨텍스트 생성
    → x: undefined, foo: <function> 메모리 할당

2) 실행 단계 (#Execution Phase #실행 단계)
     → x = 10 실행
     → foo() 호출
        ├─ Creation Phase
        │  → 함수 실행 컨텍스트 생성
        │  → y: undefined 메모리 할당
        └─ Execution Phase
           → y = 20 실행
           → console.log(x + y) 실행
```

- 클로드 참고자료
    
    ---
    
    # "평가"와 "실행" 용어 정리
    
    ## 핵심 정리
    
    **출처**: [Stack Overflow - Creation and Execution Phase in ECMAScript Spec](https://stackoverflow.com/questions/62935334/creation-and-execution-phase-in-ecmascript-specification)
    
    ```
    ✅ 당신의 이해:
    - 평가 = 실행 컨텍스트를 생성하는 것
    - 실행 = 말 그대로 실행하는 것
    
    → 맞습니다!
    
    ```
    
    ---
    
    ## 1. ECMAScript 스펙의 공식 용어
    
    **출처**: [ECMAScript 2026 Specification](https://tc39.es/ecma262/) 및 [Stack Overflow 답변](https://stackoverflow.com/questions/62935334/creation-and-execution-phase-in-ecmascript-specification)
    
    ### 스펙에는 "Creation Phase"라는 용어가 없습니다!
    
    스펙에서는 다음 순서로 표현됩니다:
    
    ```jsx
    // 스펙의 실제 표현 (의사 코드)
    1. FunctionDeclarationInstantiation(functionObject, argumentsList)
       // ↑ 이게 "평가" 단계에 해당
    
    2. Evaluation of FunctionStatementList
       // ↑ 이게 "실행" 단계에 해당
    
    ```
    
    **출처**: Stack Overflow 답변에서 *"First, all variables are getting declared (the scope and its bindings are created), then the code is executed"*라고 설명합니다.
    
    ---
    
    ## 2. 일반적으로 사용되는 용어 (블로그, 튜토리얼)
    
    **출처**: [freeCodeCamp](https://www.freecodecamp.org/news/execution-context-how-javascript-works-behind-the-scenes/), [JavaScript Tutorial](https://www.javascripttutorial.net/javascript-execution-context/)
    
    ### 블로그/튜토리얼에서 사용하는 용어:
    
    | 단계 | 영어 | 한국어 | 설명 |
    | --- | --- | --- | --- |
    | 1단계 | **Creation Phase** | **생성 단계** | 실행 컨텍스트 생성 + 메모리 할당 |
    | 2단계 | **Execution Phase** | **실행 단계** | 코드를 실제로 한 줄씩 실행 |
    
    ---
    
    ## 3. "평가(Evaluation)"의 정확한 의미
    
    **출처**: [ECMAScript Spec - Evaluation](https://tc39.es/ecma262/) 및 [MDN - Execution model](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model)
    
    ### 스펙에서 "Evaluation"의 의미:
    
    ```jsx
    // 예시: 변수 선언문의 Evaluation
    let x = 10;
    
    // 스펙에서는 이렇게 표현:
    // 1. Evaluation of VariableDeclaration
    //    → 변수를 환경 레코드에 바인딩
    // 2. Evaluation of Initializer (10)
    //    → 초기화 값 평가
    // 3. 값 할당
    
    ```
    
    **핵심**: `Evaluation`은 "코드를 평가하고 그 결과를 생성하는 것" 전체를 의미합니다.
    
    ---
    
    ## 4. 정확한 용어 매핑
    
    ### ECMAScript 스펙 ↔ 일반 용어
    
    ```
    📚 ECMAScript 스펙 용어:
    ├─ 1) Declaration Instantiation
    │    (선언 인스턴스화)
    │    = 변수/함수 선언을 환경 레코드에 등록
    │
    └─ 2) Evaluation
         (평가)
         = 코드를 실행하고 값을 생성
    
    ↕️ 대응
    
    📝 블로그/튜토리얼 용어:
    ├─ 1) Creation Phase (생성 단계)
    │    = Declaration Instantiation에 해당
    │    = 실행 컨텍스트 생성 + 메모리 할당
    │
    └─ 2) Execution Phase (실행 단계)
         = Evaluation에 해당
         = 코드 실행
    
    ```
    
    ---
    
    ## 5. 구체적 예시로 이해하기
    
    ```jsx
    var x = 10;
    function foo() {
      var y = 20;
      console.log(x + y);
    }
    foo();
    
    ```
    
    ### 용어별로 설명:
    
    ```
    🔷 방법 1: 스펙 용어 사용
    ├─ 1) GlobalDeclarationInstantiation
    │    → x: undefined, foo: <function> 등록
    │
    └─ 2) Evaluation of Script
         → x = 10 실행
         → foo() 호출
            ├─ FunctionDeclarationInstantiation
            │  → y: undefined 등록
            └─ Evaluation of FunctionBody
               → y = 20 실행
               → console.log(x + y) 실행
    
    🔷 방법 2: 일반 용어 사용
    ├─ 1) Creation Phase (생성 단계)
    │    → 실행 컨텍스트 생성
    │    → x: undefined, foo: <function> 메모리 할당
    │
    └─ 2) Execution Phase (실행 단계)
         → x = 10 실행
         → foo() 호출
            ├─ Creation Phase
            │  → 함수 실행 컨텍스트 생성
            │  → y: undefined 메모리 할당
            └─ Execution Phase
               → y = 20 실행
               → console.log(x + y) 실행
    
    ```
    
    ---
    
    ## 6. 당신의 질문에 대한 정확한 답변
    
    **출처**: 위의 모든 자료 종합
    
    ### Q1: "평가"는 실행 컨텍스트를 생성하는 건가?
    
    ```
    ✅ 부분적으로 맞습니다!
    
    정확히는:
    - "평가(Evaluation)" = 코드를 평가하고 실행하는 전체 과정
    - 이 과정에는 다음이 포함됩니다:
      1) Declaration Instantiation (실행 컨텍스트 생성 + 선언 등록)
      2) 코드 실행
    
    일반적으로 말할 때:
    - "생성 단계" = 실행 컨텍스트 생성 ✅
    - "실행 단계" = 코드 실행 ✅
    
    ```
    
    ### Q2: "실행"은 말 그대로 실행하는 거?
    
    ```
    ✅ 맞습니다!
    
    "실행 단계(Execution Phase)" = 코드를 한 줄씩 실행하는 단계
    - 변수에 값 할당
    - 함수 호출
    - 표현식 계산
    
    ```
    
    ---
    
    ## 7. 권장하는 용어 사용법
    
    **실무/학습 상황에서 추천**:
    
    ```jsx
    // ✅ 이렇게 말하세요:
    "JavaScript 엔진은 코드를 실행할 때
     1) 먼저 생성 단계에서 실행 컨텍스트를 만들고
     2) 그 다음 실행 단계에서 코드를 실행합니다"
    
    // ⚠️ 스펙 용어는 필요할 때만:
    "ECMAScript 스펙에서는
     Declaration Instantiation과 Evaluation으로 구분합니다"
    
    ```
    
    ---
    
    ## 정리
    
    **출처**: 모든 참고 자료 종합
    
    | 용어 | 의미 | 하는 일 |
    | --- | --- | --- |
    | **생성 단계** (Creation Phase) | 실행 컨텍스트 생성 | • 메모리 할당<br>• 변수 선언 등록 (undefined)<br>• 함수 전체 저장<br>• 스코프 체인 설정 |
    | **실행 단계** (Execution Phase) | 코드 실행 | • 변수에 값 할당<br>• 함수 호출<br>• 표현식 계산<br>• 코드 한 줄씩 실행 |
    
    **당신의 이해가 정확합니다!** ✅
    
    ---
    
    ## 참고 자료
    
    - [ECMAScript 2026 Specification](https://tc39.es/ecma262/)
    - [Stack Overflow - Creation and Execution Phase](https://stackoverflow.com/questions/62935334/creation-and-execution-phase-in-ecmascript-specification)
    - [MDN - Execution model](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model)
    - [freeCodeCamp - Execution Context](https://www.freecodecamp.org/news/execution-context-how-javascript-works-behind-the-scenes/)
- 참고
    - **출처**: [ECMAScript Spec - Evaluation](https://tc39.es/ecma262/) 및 [MDN - Execution model](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model)
    - **출처**: [ECMAScript 2026 Specification](https://tc39.es/ecma262/) 및 [Stack Overflow 답변](https://stackoverflow.com/questions/62935334/creation-and-execution-phase-in-ecmascript-specification)
    - **출처**: [Stack Overflow - Creation and Execution Phase in ECMAScript Spec](https://stackoverflow.com/questions/62935334/creation-and-execution-phase-in-ecmascript-specification)

# 구체적으로 실행 컨텍스트에 식별자가 어떻게 등록이 되는가?

```jsx
foo 함수가 '호출!!!!!!!!' 되면 
// → callFunction(foo) 실행
// → 아래의 1~5 단계가 순차적으로 진행
// → 이때, 3단계에서 '식별자 등록' 이 일어남 

```

(#⭐⭐⭐ 이렇게 보니까, 코드 흐름으로 보니까, 추상적이지도 않고 좋다) 

```jsx
// 의사 코드로 표현:

function callFunction(func) {
  // 1. 실행 컨텍스트 생성
  const newContext = {
    LexicalEnvironment: createEnvironment(),
    VariableEnvironment: createEnvironment(),
    ThisBinding: determineThis()
  };
  
  // 2. 콜 스택에 푸시 (동시에 일어남!)
  callStack.push(newContext);
  // ↑ 이 순간부터 newContext가 "활성 실행 컨텍스트"
  
  // 3. Declaration Instantiation(ECMAScript 상 용어) (#식별자 등록 단계 #⭐⭐⭐)
  instantiateDeclarations(newContext);
  
  // 4. 코드 실행 (#실행 단계 #⭐⭐⭐)
  executeCode(func.code);
  
  // 5. 종료 시 콜 스택에서 제거
  callStack.pop();
}

// 호출 시:
foo();  
// → callFunction(foo) 실행
// → 위의 1~5 단계가 순차적으로 진행
```

## 📊 정확한 플로우
```
foo() 호출
    ↓
┌─────────────────────────────────────┐
│ 1. 새 Execution Context 객체 생성    │
│    {                                │
│      LexicalEnvironment: {...},    │
│      VariableEnvironment: {...},   │
│      ThisBinding: ...              │
│    }                                │
└─────────────────────────────────────┘
    ↓ (즉시)
┌─────────────────────────────────────┐
│ 2. Call Stack에 Push                │
│    (생성과 동시에 활성화!)            │
│                                     │
│    Call Stack:                      │
│    ┌───────────────┐                │
│    │ foo Context   │ ← 여기!        │
│    ├───────────────┤                │
│    │ Global Context│                │
│    └───────────────┘                │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. Declaration Instantiation        │
│    (생성 단계)                       │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. Code Evaluation                  │
│    (실행 단계)                       │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 5. Call Stack에서 Pop               │
│    (종료)                            │
└─────────────────────────────────────┘
```

# 실행 단계에서는 이 식별자를 어떻게 참고 하는가?

```jsx
⭐⭐⭐ 이렇게 코드로 순서가 정리되니까 편하다. 

// 의사 코드로 표현:

function callFunction(func) {
  // 1. 실행 컨텍스트 생성
  const newContext = {
    LexicalEnvironment: createEnvironment(),
    VariableEnvironment: createEnvironment(),
    ThisBinding: determineThis()
  };
	  /*
		  // 이 시점의 newContext:
			{
			  LexicalEnvironment: {
			    EnvironmentRecord: {},  // ← 비어있음 (식별자 없음)
			    outer: Global Env
			  },
			  VariableEnvironment: {
			    EnvironmentRecord: {},  // ← 비어있음 (식별자 없음)
			    outer: Global Env
			  },
			  ThisBinding: globalThis
			}
	  */
  
  
  // 2. 콜 스택에 푸시 (동시에 일어남!)
  callStack.push(newContext);
  // ↑ 이 순간부터 newContext가 "활성 실행 컨텍스트"
			  Call Stack:
			┌─────────────────────────┐
			│ foo Context             │ ← 추가됨!
			│  Env: {}  (비어있음)    │
			├─────────────────────────┤
			│ Global Context          │
			└─────────────────────────┘
  
  // 3. Declaration Instantiation
  instantiateDeclarations(newContext);
  
		  // [instantiateDeclarations 내부] 
			  // 1) 이제 식별자를 등록! 
					/* function instantiateDeclarations(context) {
					  const env = context.VariableEnvironment.EnvironmentRecord;
					  
					  // foo 함수 코드 스캔:
					  // "var y = 20;" 발견!
					  
					  env.CreateMutableBinding("y");
					  env.InitializeBinding("y", undefined);
					} */
			
				// 이 시점의 foo Context:
					/* {
					  LexicalEnvironment: {
					    EnvironmentRecord: {
					      y: undefined  // ← 식별자 등록됨!
					    },
					    outer: Global Env
					  },
					  ...
					} */
			
			
  
  // 4. 코드 실행
  executeCode(func.code);
	  
	  /*
			  코드 실행:
				  1) var y = 20;
						  → y에 20 할당
					2) console.log(x + y);
							→ x 검색, y 검색, 출력
					3) x 검색 
						-  resolveIdentifier(x) 실행 : 여기에서 현재 E.V 없으면 -> OUTER 뒤져서 가져옴
						
					4) y 검색
						-  resolveIdentifier(y) 실행 : 여기에서 현재 E.V 없으면 -> OUTER 뒤져서 가져옴

	  */
	  
  
  // 5. 종료 시 콜 스택에서 제거
  callStack.pop();
}

// 호출 시:
foo();  
// → callFunction(foo) 실행
// → 위의 1~5 단계가 순차적으로 진행
```

- 값 검색 : `resolveIdentifier` 함수 의사 코드 (#해당 식별자에 바인딩 된 value 를 끄집어 내는 것 임!)
    
    ```jsx
    // 의사 코드로 표현:
    
    function resolveIdentifier(name) {  // name = "x"
      // 1. 현재 실행 중인 컨텍스트 가져오기
      const currentContext = callStack.top();
      
      // 2. LexicalEnvironment 가져오기
      let env = currentContext.LexicalEnvironment;
      
      // 3. 스코프 체인을 따라 검색
      while (env !== null) {
        // 4. 현재 Environment의 Record에서 검색
        if (env.EnvironmentRecord.hasBinding(name)) {
          // 발견!
          return env.EnvironmentRecord.getBindingValue(name);
        }
        
        // 5. 없으면 outer로 이동
        env = env.outer;
      }
      
      // 6. 끝까지 없으면 에러
      throw new ReferenceError(`${name} is not defined`);
    }
    ```
    

# 그러면, 스코프 라는 것은?

```jsx
블록 스코프랑 
함수 스코프 
전역 스코프 

그러면 이 스코프에 대해서 평가와 실행이 어떻게 이뤄지지 
```

```jsx
해당 변수가 유효한 범위!

즉,  
```

- 블록 스코프를 통과 할 때, 렉시컬 환경과 실행 컨텍스트가 어떻게 동작하는지
    
    ```jsx
    var x = 10;  // 전역
    
    function foo() {
      var y = 20;  // 함수 스코프
      
      {
        let z = 30;  // 블록 스코프
        console.log(x, y, z);  // 10, 20, 30
      }
      
      console.log(z);  // ReferenceError
    }
    
    foo();
    ```
    
    ```jsx
    // ============ 1. foo() 호출 ============
    FooExecutionContext = {
      LexicalEnvironment: {
        EnvironmentRecord: { y: 20 },
        outer: GlobalLexicalEnvironment
      }
    }
    
    // ============ 2. 블록 { } 진입 ============
    
    // 2-1) oldEnv 저장
    oldEnv = FooExecutionContext.LexicalEnvironment
    // = { EnvironmentRecord: { y: 20 }, outer: Global }
    
    // 2-2) 새 Lexical Environment 생성
    blockEnv = {
      EnvironmentRecord: { z: 30 },
      outer: oldEnv  // ← 이전 환경을 가리킴!
    }
    
    // 2-3) 실행 컨텍스트의 LexicalEnvironment 교체!
    FooExecutionContext.LexicalEnvironment = blockEnv
    
    // 현재 상태:
    FooExecutionContext = {
      LexicalEnvironment: {
        EnvironmentRecord: { z: 30 },
        outer: {
          EnvironmentRecord: { y: 20 },
          outer: GlobalLexicalEnvironment
        }
      }
    }
    
    // ============ 3. 블록 종료 ============
    
    // LexicalEnvironment를 oldEnv로 복원!
    FooExecutionContext.LexicalEnvironment = oldEnv
    
    // 복원 후:
    FooExecutionContext = {
      LexicalEnvironment: {
        EnvironmentRecord: { y: 20 },
        outer: GlobalLexicalEnvironment
      }
    }
    // → z는 이제 접근 불가!
    ```
    
    ---
    
    ## 3. "스택 구조"의 의미
    
    **출처**: [Medium - Block Scope Stack Structure](https://cabulous.medium.com/javascript-execution-context-lexical-environment-and-block-scope-part-3-fc2551c92ce0)
    
    Lexical Environment는 변수에 대해 스택과 같은 구조를 유지하므로, 같은 이름의 변수들이 서로 충돌하지 않습니다. 
    ```
    📚 스택(Stack) 동작:
    
    블록 진입 전:
    ┌─────────────────┐
    │ y: 20           │ ← 현재 LexicalEnvironment
    │ outer: Global   │
    └─────────────────┘
    
    블록 진입 (PUSH):
    ┌─────────────────┐
    │ z: 30           │ ← 새 LexicalEnvironment (현재)
    │ outer: ↓        │
    ├─────────────────┤
    │ y: 20           │ ← 이전 LexicalEnvironment
    │ outer: Global   │
    └─────────────────┘
    
    블록 종료 (POP):
    ┌─────────────────┐
    │ y: 20           │ ← 복원된 LexicalEnvironment
    │ outer: Global   │
    └─────────────────┘
    // z는 제거됨 (Garbage Collection)
    ```
    

- 이 경우에, 블록 스코프를 통과 했을 때, var 의 경우 어떤 실행컨텍스트 또는 스코프에 할당이 되는 걸까?
    
    ```jsx
    var x = 10;  // 전역
    
    function foo() {
      var y = 20;  // 함수 스코프
      
      {
        let z = 30;  // 블록 스코프
        var a = 50;  // ✅ 함수 스코프! (블록 무시)
        console.log(x, y, z);  // 10, 20, 30
      }
      
      console.log(z);  // ReferenceError ← 블록 밖
      console.log(a);  // 50 ✅ 접근 가능! ← var는 함수 스코프
    }
    
    foo();
    ```
    

### `var a = 50`  // ✅ 함수 스코프! → 이걸 바로 설명하면 좋을 거 같은데, 바로 설명이 안 된다. (#📛📛📛 #약해)

![image.png](attachment:0992550f-53d3-48d5-b6fd-ee7109ce22fb:image.png)

- AI 설명
    
    정확합니다! 👍 MDN 문서로 확인해드리겠습니다.# 정답입니다! ✅
    
    ## MDN 근거
    
    **출처**: [MDN - Block Statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)
    
    var로 선언된 변수 또는 non-strict 모드의 함수 선언은 블록 스코프를 갖지 않습니다. 블록 내에서 도입된 변수는 포함하는 함수나 스크립트로 스코프가 지정되며, 변수 설정의 효과는 블록 자체를 넘어 지속됩니다.
    
    ---
    
    ## 당신의 코드 분석
    
    ```jsx
    var x = 10;  // 전역
    function foo() {
      var y = 20;  // 함수 스코프
    
      {
        let z = 30;  // 블록 스코프
        var a = 50;  // ✅ 함수 스코프! (블록 무시)
        console.log(x, y, z);  // 10, 20, 30
      }
    
      console.log(z);  // ReferenceError ← 블록 밖
      console.log(a);  // 50 ✅ 접근 가능! ← var는 함수 스코프
    }
    foo();
    
    ```
    
    ---
    
    ## 내부 동작
    
    ```jsx
    // ============ foo() 호출 시 평가 단계 ============
    
    FooExecutionContext = {
      LexicalEnvironment: {
        EnvironmentRecord: {
          y: undefined,  // var y
          a: undefined   // ✅ var a도 여기 등록! (블록 무시)
        },
        outer: GlobalLexicalEnvironment
      }
    }
    
    // ============ 블록 진입 ============
    
    // 블록의 Lexical Environment 생성
    BlockLexicalEnvironment = {
      EnvironmentRecord: {
        z: <uninitialized>  // let z만 여기!
        // a는 여기 없음! ← var는 블록 무시
      },
      outer: FooLexicalEnvironment
    }
    
    // ============ 코드 실행 ============
    
    var y = 20;  // foo의 y에 할당
    let z = 30;  // 블록의 z에 할당
    var a = 50;  // ✅ foo의 a에 할당! (블록 무시)
    
    // ============ 블록 종료 후 ============
    
    console.log(z);  // ReferenceError ← z는 블록에만 있음
    console.log(a);  // 50 ✅ ← a는 foo 함수 스코프에 있음!
    
    ```
    
    ---
    
    ## 시각적 비교
    
    **출처**: [MDN - Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures)
    
    ```
    📦 foo 함수 스코프
    ├─ y: 20       (var)
    ├─ a: 50       (var) ← 블록 안에 있어도 여기!
    │
    └─ 📦 블록 스코프
       └─ z: 30    (let) ← 블록에만 존재
    
    블록 종료 후:
    ├─ y: 20 ✅ 접근 가능
    ├─ a: 50 ✅ 접근 가능
    └─ z: ❌ 접근 불가 (ReferenceError)
    
    ```
    
    ---
    
    ## MDN 예시
    
    **출처**: [MDN - Block Statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)
    
    ```jsx
    var x = 1;
    {
      var x = 2;  // ← 같은 변수!
    }
    console.log(x);  // 2
    
    ```
    
    이것은 2를 출력합니다. 왜냐하면 블록 내의 var x 문이 블록 이전의 var x 문과 같은 스코프에 있기 때문입니다.
    
    **대조**: let의 경우
    
    ```jsx
    let x = 1;
    {
      let x = 2;  // ← 다른 변수!
    }
    console.log(x);  // 1
    
    ```
    
    x = 2는 정의된 블록으로 스코프가 제한됩니다.
    
    ---
    
    ## 실제 테스트
    
    ```jsx
    var x = 10;
    
    function foo() {
      var y = 20;
    
      {
        let z = 30;
        var a = 50;
        console.log("블록 안:", x, y, z, a);  // 10, 20, 30, 50
      }
    
      console.log("블록 밖:", x, y, a);  // 10, 20, 50 ✅
      console.log(z);  // ReferenceError ❌
    }
    
    foo();
    
    ```
    
    ---
    
    ## 핵심 정리
    
    ```
    ✅ var의 스코프 규칙:
    
    1. 블록 무시:
       - var는 {} 블록을 무시
       - 가장 가까운 함수 스코프에 등록
    
    2. 함수 스코프:
       - 함수 내부 어디서든 선언하면 → 함수 스코프
       - 함수 밖에서 선언하면 → 전역 스코프
    
    3. 호이스팅:
       - 선언이 함수 최상단으로 끌어올려짐
       - undefined로 초기화
    
    ```
    
    ---
    
    ## 비교표
    
    | 위치 | var | let | const |
    | --- | --- | --- | --- |
    | **블록 내부** | 함수 스코프 | 블록 스코프 | 블록 스코프 |
    | **함수 내부** | 함수 스코프 | 함수 스코프 | 함수 스코프 |
    | **전역** | 전역 스코프 | 전역 스코프 | 전역 스코프 |
    
    **핵심**: 블록은 let과 const 선언만 스코프로 만들고, var 선언은 만들지 않습니다.
    
    ---
    
    ## 📚 참고 링크
    
    - [MDN - Block Statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)
    - [MDN - var](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var)
    - [MDN - Scope Glossary](https://developer.mozilla.org/en-US/docs/Glossary/Scope)
    
    ---
    
    ## ✅ 체크리스트
    
    - [x]  var는 블록 스코프 무시 확인
    - [x]  var는 함수 스코프 확인
    - [x]  MDN 근거 제시
    - [x]  내부 동작 설명
    - [x]  시각적 비교
    - [x]  실제 예시
    - [x]  출처 링크 첨부
    
    당신의 이해가 **완벽합니다!** 🎯
    

### 그러면 호이스팅은 무엇 입니까?

```jsx
호이스팅은 끌어올려진 것, 이란 의미 이고, 

js 엔진은 '평가' 단계에서 1) 식별자를 등록 2) 초기화를 진행하는데 

이것이 식별자의 선언부가, 해당 스코프의 최상단으로 끌어올려진 것 같은, 효과를 낸다, 

라고 해서 

호이스팅 이라고 이야기를 한다. 

그럼 호이스팅이라고 하는 건, '평가' 단계에서 '식별자 등록 + 초기화' 가 이루어진 상태 
라고 보면 된다. 
```