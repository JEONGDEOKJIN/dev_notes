
# what
## 결함 설명 


- 처음엔 basicEntry 계산하는 useMemo 에서 에러가 났음 
	- 그걸 가공하는 target 은 다 들어오고 있었음 
	- 그러면, 이 basicEntry 를 사용할 때, basicEntry 가 다 가공되지 않았는데 호출해서 발생하는 것 

- 엔터를 치면 다시 들어옴 

# why
## 현재 상황 및 결함의 원인

## 결함의 근본 원인 


# how
## 내가 한 조치

1. 해당 변수가 사용되는 곳을 찾는다. 
	-> optional chaining 을 건다 
	-> undefined, null 일 때, return null 을 한다. 
	-> useMemo, useEffect 등 이라면, '의존성' 을 건다. 


# so, what
## 몰랐던 것 
- 컴포넌트 내에서, 실행되는 훅(useState, useMemo, 등) 의 개수, 순서는 동일 해야 한다. 
	> 그래서 useMemo 로 변수화 를 하더라도, 만약, 실행이 안 될 수 있는 거면, 훅 규칙 위반이 나게 된다.
	
- 그러면 해당 버그가 사라졌다는 건 
useMemo 를 가공해서 basicEntry 를 만들어내는 로직이 
리렌더링 과정에서 
실행되는 '순서' 및 '횟수' 가 동일해졌다는 걸 의미

- 중간에 '탈출 로직' 이 있는지 봐야 함 
1) if(어떤 조건) {return null}
2) return 문 
3) 등등

- useMemo 은 한 컴포넌트에서 훅 규칙을 고려하면 사용할 수 있는 개수가 제한적임. 순수함수를 사용해서 useMemo 의 개수 및 순서 제한 규칙을 통과할 수 있게 활용 가능 

- 가공을 통해서 만들어진 결과물이 onClick 핸들러의 매개변수로 들어가는 경우, 해당 결과물을 만드는 useMemo 는 실행이 될 수도 있고, 안 될 수도 있음 -> so, 훅 규칙 위반이 됨 
	-> 아님, 1) 렌더링 단계 2) 이벤트 처리 단계 인데, 훅 규칙위반은 렌더링 단계에 해당 
	-> useMemo 를 남발하지 않기 

- 대안 
	1) 연속된 useMemo 로 가공 순서 및 결과 값을 보장 하던 것을 순수 함수로 보장하고 
	2) useMemo 사용 횟수를 줄임으로써, 의도하지 않은 훅 렌더링에 따른 훅 위반 리스크를 줄임 
	3) 훅 렌더링 순서를 수정

- 실행이 안 된다면? 된다면? (#⭐⭐⭐ 이걸 파악해야 함) 
 - 이렇게 되어 있을 때, nhisExmnValue 가 없다고 -> 내부 useMemo 가 실행이 안 되는 건 아님 
 - 내부 useMemo 의 로직이 변경되는 것 임 
 - render more hooks 규칙 위반인지를 보려면, 컴포넌트 전체에서 이 useMemo 가 실행되는 걸 봐야 함
	 const basicItems = useMemo(() => {
    // ...
  }, [nhisExmnValue]); // 첫 번째 훅


- 그리고 함수를 밖으로 명확하게 빼서 사용해야 
	1) 이 함수가 실행될 때 의존하는게 뭔지 알 수 있음 
	
	2) 그렇지 않고, 전역스코프 등에 의존해서 함수 값 등을 가져오게 되면 
		> 지금처럼 실행 순서 등이 영향을 받게 됨 




## 앞으로 시간을 줄이려면 

- 지금 이 상황에서 이 에러가 나면, 명확하게 어디에서 에러가 나는지를 모르는 상황이 됨 
	> 이걸 최대한 지양해야 함 
	> so, useMemo 도 하나의 훅 이기 때문에, 순수함수를 최대한 쓰고 이건 적절하게


## 추가 공부하면 좋을 것