# 결함 설명

- 처음에는 부모-자식 간의 연결 고리가 불안해서 발생한 문제라고 생각했음.

# 현재 상황 및 결함의 원인

- 근본 원인은 부모-자식 간의 연결고리가 아니라, 최근 추가한 그 기능이 아니라, '문진 복구 기능' 이 문제였음. 즉, '문진 복구 기능' 을 할 때, '필수확인UI' 의 경우, required 필드에 들어가야, 비로소 문진이 복구되는 구조로 되어 있었음.
  1.  문진 복구 기능 중 왜 required 만 예외로 다뤄지고 있는지는 모르겠음.
  2.  이로 인해 발생하는 사이드이펙트를 어떻게 해야 할지에 대한 고민

# 결함의 근본 원인

- 문진 복구 기능이 통일성이 없는 상황

# 내가 한 조치

- 필수문항 UI 리스트를 받았을 때, id를 required 키에 바인딩 하기

# 앞으로 시간을 줄이려면

- 근본적으로, 무엇을, 어떻게 고쳐야 하는가, 에 대해서, 나 스스로 확신이 없으면, 불안감이 생김. 그 확신을 채워주는 것은, 나 스스로 공부를 하는 것. 이게 필요함. 이게 작동할 수 밖에 없다는 확신!

# 배운 것

- 기능간의 책임을 명확하게 분리(단일책임 원칙)
- 직교성 : 서로 관련 없는 기능은 서로에게 영향을 주지 않아야 함. '문진 항목의 속성(필수 여부)'과 '문진 복구 메커니즘'은 서로 독립적이어야. 하지만 현재는 ⭐ '필수'라는 속성이 '복구' 메커니즘의 동작 방식을 바꿔버리므로, 두 기능이 직교하지 않고 강하게 결합된 상태입니다. 좋은 설계는 이 둘을 분리하여 복구 기능은 어떤 종류의 문항이든 동일한 방식으로 처리하도록 만듦 (gemini참고) ⭐

- 데이터 기반 로직 구현 : '문진 복구 기능'은 위에서 정의한 goodState.items 배열을 받아 처리하기만 하면 됨. 어떤 항목이 필수인지는 신경 쓰지 않음. 복구 기능의 책임은 오직 "데이터를 UI에 다시 그려주는 것"까지. (gemini 참고)

# 추가 공부하면 좋을 것

- 문진 복구 기능을 설계할 때, required 키 같은, 예상치 못 한 상황이 없도록 해야 할 것 임
- 이걸 개념적으로 뭐라고 하면 좋을까.
