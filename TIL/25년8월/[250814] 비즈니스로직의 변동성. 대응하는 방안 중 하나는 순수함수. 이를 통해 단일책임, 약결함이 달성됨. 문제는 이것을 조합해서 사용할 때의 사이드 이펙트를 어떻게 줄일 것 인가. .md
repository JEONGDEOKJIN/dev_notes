# 결함 설명

- 문진 항목에서 valid 판단시, 필수항목 체크 된 것, 은 제외하고 판단해야 함
- 즉, 필수항목이 아닌 경우(inqyMdcsMdcsYn) 이 false 이면, 이제, 체크 안 해도 valid 가 되어야만 함

# 현재 상황 및 결함의 원인

- inqyMdcsMdcsYn 필드에 대한 고려가 없었음.

# 결함의 근본 원인

- 'api 데이터 기반의 파싱(컴포넌트 설계)', '기획 > 요구사항 > 요구사항별 담당하고 있는 함수'에 대한 쉬운 이해, 파싱 로직을 잘 떠올리는 역량이 필요했음.

# 내가 한 조치

- 판단의 대상이 되는 root question 을 필터링 할 때, inqyMdcsMdcsYn 가 false 인 경우, valid 판단 대상에 넣지 않음.

- 우선, 처음에는, 이 로직을 반영할 때, 머릿속에 다 안그려졌었음. 복잡했음. 이걸, 변수화 해서 다시 어떻게 해야 하나 라는 생각을 했었음. VALID 처리하는 로직에서 useMemo 를 가져와서 수정해야 하나...
  => 그런데, 1) rootQuestion 이 valid 의 대상이 된다. 2) findRootQuestions 에서 rootQuestion 를 return 한다. 라는 걸 알고 있으니, 필수항목필드를 어디에서 반영하면 되는지를 빠르게 알 수 있었다.
  => 즉, 해당 요구사항을 만족하기 위해 어떤 기능이 필요하고, 해당 기능을 어떤 함수에서 담당하는지를 알고 있으면, 대처가 빨라진다. -> 이를 쉽게 알 수 있기 위해서는, 내가 잘 이해할 수 있는 수준에서 코드를 쉽게, 모듈화 해서 짜는 것. (#결국, 비슷한 결론의 귀결이긴 한데, 기능을 분리하고, 내가 쉽게 이해하는 것의 필요성을 다시 느낄 수 있었따.)

# 앞으로 시간을 줄이려면

- api 데이터를 그대로 사용하는 컴포넌트 설계가 필요
- 동시에, 요구 사항의 항목별로 모듈화 되고, 강하게 결합하지 않는 함수로 작성하기

# 추가 공부하면 좋을 것

- selector 패턴 : API 데이터를 그대로 사용하면서도, UI에서 사용하기 좋은 형태로 가공, 파생된 값을 효율적으로 관리
  1.  파생된 상태(derived state) 를 만들어주는 '순수함수' 를 활용
  2.  '데이터 가공 로직'을 '컴포넌트'나 '비즈니스 로직' 과 분리
      CF. 비즈니스 로직의 예시 1. 유효성 규칙 - ex) nextQstn 에 있는 질문ID 가 OK 되었을 때, 부모가 OK 된다. - ex) 필수항목이 valid 되어야 한다. 2. 데이터 가공 - 어떤 항목을 root 질문으로 설정할 것 인가. (#정책적 고민이 기반이 되고 -> 이게 코드로 표현되는 것. #그리고, 충분히 바뀔 수 있음) 3. 워크 플로우 순서 - 추가검사를 보내고 -> 그 다음 일정 등록을 한다. (#이것 또한 변경될 수 있음)
      => '변경될 수 있다.' 라는 게 핵심 => 그래서, 각 기능을 최대한 순수함수로 만든다면?
      => 1) 모듈화 2) 사이드이펙트가 적게 할 수 있는건가
- '순수 함수' 를 작성하기
  1.  외부 상태에 영향을 주지도 않고, 영향을 받지도 않는 함수임
      => 이걸 작성하게 되면, DATA 가 변경되지 않는 이상, 안정적으로 함수가 실행이 될 수 있음.
  2.  반대로 'Side Effect(부수 효과)' 란?
- 상태 기계

  1.  복잡한 상황의 경우, XState 라이브러리 공식 문서를 통해 상태 기계에 대해서 공부 -> if/else, useEffect 등으로 그려야 하는 UI 를 한번에 파악이 가능

- 비즈니스 로직은 변경될 수 있고 → 거기에 대응하는 방식 중 하나는 ‘순수함수’ 로 기능을 쪼개는 것. → 그랬을 때, 1) 단일 책임 2) 다른 곳에 영향을 주지 않으니까, 약결합 이 달성되는 건가? 3) 다만, 그것을 활용할 때의 사이드 이펙트를 어떻게 조절할 것 인가!
