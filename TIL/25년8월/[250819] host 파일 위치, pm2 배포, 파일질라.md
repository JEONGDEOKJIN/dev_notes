## 1. Network Infrastructure & Traffic Management

```
 L4는 OSI 7계층(OSI 7 Layer) 모델 중 **4계층(Transport Layer)**에서 동작하는 로드밸런서

 L4 로드밸런싱의 원리: L4 스위치는 TCP/UDP 헤더에 있는 Source/Destination IP 주소와 포트 번호를 보고 패킷을 어떤 백엔드 서버로 보낼지 결정합니다. 즉, 애플리케이션의 콘텐츠(HTTP 헤더, URL 등)를 보지 않고 순수하게 네트워크 정보만을 이용해 요청을 분산(Distribute)

 VIP (Virtual IP): 사용자들이 접속하는 L4 스위치의 대표 IP 주소. 클라이언트는 실제 서버들의 IP(Real IP)를 알 필요 없이 VIP로만 요청을 보내고, L4가 이 요청을 실제 서버들로 NAT(Network Address Translation) 하거나 포워딩합니다. 이는 백엔드 서버의 구성을 외부로부터 **추상화(Abstraction)**하는 역할


Health Check 실패 문제: "하나를 죽이면 -> 2호기가 안 되는 상황"이라는 현상은 L4의 Health Check 기능이 제대로 설정되지 않았을 가능성이 높음.
L4는 주기적으로 백엔드 서버의 상태를 확인하여 장애가 발생한 서버를 **트래픽 분산 대상에서 제외(Failover)**해야 합니다. 이 기능이 오작동하면 L4는 이미 다운된 서버로 계속 트래픽을 보내 블랙홀 현상을 유발합니다. 혹은 **세션 클러스터링(Session Clustering)**이 구성되지 않아 세션 정보가 동기화되지 않는 문제일 수도.
```

## 2. System Architecture & Service Deployment

```
시스템은 전형적인 3-Tier 아키텍처 또는 그 변형으로 보이며, 서버 배포 방식에 대한 논의가 포함되어 있습니다.

Web Server (e.g., Nginx, Apache): 주로 정적 콘텐츠(Static Contents), 즉 HTML, CSS, JavaScript, 이미지 파일 등을 서빙하는 역할을 합니다. 또한 클라이언트의 요청을 받아 적절한 WAS로 전달하는 **리버스 프록시(Reverse Proxy)**의 역할도 수행합니다.

WAS (Web Application Server, e.g., Tomcat, Node.js): 데이터베이스 조회, 비즈니스 로직 수행 등 **동적 콘텐츠(Dynamic Contents)**를 생성하는 서버입니다. "예약 들어올 때는 무조건 WAS 타야" 한다는 말은, 예약 처리 로직이 WAS에 구현되어 있다는 의미입니다.

배포 아키텍처: "한 서버에서 WEB, WAS 같이 돌려"라는 것은 단일 물리/가상 서버 인스턴스에 Web Server 프로세스와 WAS 프로세스를 함께 배포한 구조입니다. 이는 리소스 관리가 단순하지만, 둘 중 하나에 장애가 발생하면 다른 쪽도 영향을 받는 **결합도(Coupling)**가 높은 구성입니다.

고가용성(High Availability, HA): "웹 서버 2대"를 운영하는 것은 가용성을 높이기 위한 서버 이중화(Redundancy) 구성입니다. L4 로드밸런서와 함께 HA를 구축하여 **무중단 서비스(Zero Downtime)**를 지향하는 것이 일반적인 목표입니다. 현재 이 HA 구성이 깨져 있는 상태로 보임.
```

HTTPS (HTTP over TLS/SSL): "Https로 하면 인증서가 필요하니까"라는 언급은 TLS(Transport Layer Security) 프로토콜을 의미합니다. 클라이언트와 서버 간의 통신 채널을 암호화하여 **기밀성(Confidentiality)**과 **무결성(Integrity)**을 보장합니다. 이를 위해 서버는 신뢰할 수 있는 **CA(Certificate Authority)**로부터 발급받은 SSL/TLS 인증서를 필요

인증 경로 문제: "SSO로 인증 받는 거랑, 우리가 자체 인증 한거랑 경로가 달라?"는 문제는 인증 방식에 따라 세션 관리 정책이나 인가(Authorization) 로직이 분기 처리되어 발생할 수 있는 잠재적 버그를 지적하는 것입니다. 이상적으로는 어떤 방식으로 인증되든, 일단 인증이 완료되면 애플리케이션 내에서는 동일한 **Principal(보안 주체)**로 처리되어야.
