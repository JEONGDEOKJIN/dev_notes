

# 문제해결에서 비즈니스로직의 역할
```
# 이 api 에 뭐가 있는지 
대체 이 api 를 왜 쏘는지 
어떤 api 다음에 쏴야 하는지 
병렬적으로 구성하면 안 되고, 반드시 순차적으로 들어가야 하는 경우 
payload 만 봐도 제대로 들어가고 있는지를 알고 있는지 

이런 것들이 비즈니스 로직에 대한 건가. 
이것들에 대한 이해가 반드시 필요 
```

# 명시적 return 과 암시적 return 
| 형태                        | 작동 방식        | 설명                                                |
| ------------------------- | ------------ | ------------------------------------------------- |
| `(x) => x + 1`            | ✅ 자동 return  | 괄호만 쓰면 **자동 return** 됨                            |
| `(x) => { return x + 1 }` | ✅ 명시적 return | `{}` 쓰면 **반드시 `return` 써야** 함                     |
| `(x) => { x + 1 }`        | ❌ undefined  | `{}` 쓰고 `return` 안 쓰면 **아무것도 반환 안 함 (undefined)** |


# methods.watch() 는 무한루프를 발생시키는데 useWatch 는 그렇지 않음. 차이점은? (#📛📛 보완필요)
| 항목            | `methods.watch()`           | `useWatch()`            |
| ------------- | --------------------------- | ----------------------- |
| 목적            | **즉시 값 조회** (1회성 스냅샷)       | **리액티브 감시** (값 변경 시 감지) |
| 반환            | 실행할 때마다 **새로운 객체**          | 최신 값을 유지하며 상태 변경 감지     |
| useEffect와 조합 | ❌ 무한 루프 위험 (`watch()`가 새로움) | ✅ 안전 (값 변경에만 반응)        |
| 성능            | 값 많으면 느림, 렌더마다 호출됨          | 내부 옵저버 구조라 더 효율적        |
| 사용하는 곳        | 즉시 체크, 버튼 핸들러 등             | 상태 기반 UI, 조건부 렌더링 등     |
| 의존성 배열 사용     | 위험 (`[methods.watch()]` X)  | 안정적 (`[value]`)         |



# 데이터가 변경됨 -> 이걸 000 가 알아야 함 -> 그래서 의존성을 설정해줌 
```
이것과 관련된 문제, 비슷한 문제가 사실, 계속, 반복적으로 등장한다. 
```