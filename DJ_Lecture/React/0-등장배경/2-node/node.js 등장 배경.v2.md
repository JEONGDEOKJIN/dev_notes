# Node.js 등장 배경

## 1. 라이언 달(Ryan Dahl)의 문제의식

2009년, Ryan Dahl은 기존 서버의 I/O 처리 방식에 문제가 있다고 봤다.

### 문제: 동기(블로킹) 방식의 한계

```
I/O 처리를 동기(블로킹) 방식으로 하면:
→ 해당 스레드는 작업이 끝날 때까지 "대기"
→ 대기하는 동안 아무것도 못 함
→ 동시 요청이 많아지면? 스레드를 계속 추가 생성하여 해결
→ '메모리가 낭비' 되는 문제
```

### 실제 서버에서 일어나는 일

```js
// 하나의 요청 처리 시
app.get("/user/:id", (req, res) => {
  // 1. DB에서 유저 조회      → 50ms 대기
  // 2. 파일에서 프로필 이미지 → 30ms 대기
  // 3. 외부 API 호출         → 200ms 대기
  // ---------------------------------
  // 실제 CPU 연산:             0.1ms
  // 총 대기 시간:              280ms
});

// 99.9%가 대기 시간인데, 블로킹 방식은 이 동안 스레드가 아무것도 못 함
```

### 리소스 비교

| 방식                       | 동시 접속 10,000명 처리 시     |
| -------------------------- | ------------------------------ |
| 스레드 생성 방식 (Apache)  | 스레드 10,000개 → 메모리 ~20GB |
| 이벤트 루프 방식 (Node.js) | 스레드 1개 → 메모리 ~500MB     |

---

## 2. 왜 다른 언어들은 이 문제를 해결 못 했나?

```
다른 개발자들도 이 문제를 알고 있었다. 근데 **바꿀 수 없었다.**

왜?

→ 이미 동기 I/O 라이브러리가 존재 → 수백만 개의 서비스/라이브러리/프레임워크가 동기식으로 작성 → '비동기로 바꾸면, 생태계 전체가 깨짐'
```

### 이유: 레거시의 무게

```python
# Python - 이미 이렇게 쓰고 있었음
file = open('data.txt')  # 블로킹
data = file.read()       # 블로킹
print(data)

# 수백만 개의 라이브러리가 이 방식으로 작성됨
# "비동기로 바꾸세요" → 생태계 전체가 깨짐
```

```java
// Java - 마찬가지
InputStream is = new FileInputStream("data.txt");  // 블로킹
byte[] data = is.readAllBytes();                    // 블로킹
```

**"기술적으로 가능 vs 현실적으로 가능"**

비동기로 전환하려면 언어를 새로 만드는 것과 비슷한 비용이 들었다.

---

## 3. JavaScript가 선택된 이유

### 3-1. 서버용 I/O API가 없었다

```javascript
// JS는 브라우저에서 원래 이랬음
button.addEventListener("click", function () {
  // 클릭하면 실행
});

setTimeout(function () {
  // 나중에 실행
}, 1000);
```

- 이미 "콜백", "비동기 처리" 개념에 익숙한 언어
- 결정적으로 **서버용 I/O API가 아예 없었음**
- 영향을 받을 기존 코드가 없음 → **백지 상태에서 시작 가능**

Ryan Dahl의 말:

> "JavaScript has no I/O. That's the point."
> (JS에는 I/O가 없다. 그게 핵심이다.)

### 3-2. V8 엔진의 등장 (2008)

```
2008년 이전: JS 엔진들이 느렸음 → 서버로 쓸 생각 자체를 못 함
2008년 9월: Chrome + V8 출시 → JS가 갑자기 빨라짐
2009년 5월: Ryan Dahl이 Node.js 발표
```

V8이 없었으면 Node.js도 없었다.

---

## 4. I/O란?

### 정의

- **I/O = Input/Output**
  : 서버에서는 cpu 가 직업 처리 하지 않고, cpu 입장에서의 외부장치(디스크, 네트워크, DB 등)에 맡기는 모든 작업
  : 그래서 '대기 시간' 이 발생한다. (#CPU 가 기다리는 시간을 의미! #⭐⭐⭐ #cpu 는 엄청 빠른데, 다른 장치들은 느리니까 기다리는 시간이 되고 #일을 눈 깜짝할 사이에 처리하는 cpu 입장에서는 굉장히 지루하고 낭비되는 일)

### I/O 작업의 예시

| 종류                                    | 예시                         |
| --------------------------------------- | ---------------------------- |
| 파일 I/O                                | 파일 읽기/쓰기               |
| DB I/O (#❓❓❓ #DB도 I/O 아닌가❓❓❓) | 데이터 베이스 읽기/쓰기      |
| 네트워크 I/O                            | HTTP 요청, DB 쿼리, API 호출 |
| 사용자 I/O                              | 키보드 입력, 마우스 클릭     |

### I/O는 왜 느린가?

```
L1 캐시 참조:              0.5 ns
메모리 참조:               100 ns
SSD 읽기:                  150,000 ns     (0.15 ms)
네트워크 왕복 (같은 도시):   500,000 ns     (0.5 ms)
HDD 읽기:                  10,000,000 ns  (10 ms)
네트워크 왕복 (해외):       150,000,000 ns (150 ms)
```

CPU 연산에 비해 I/O는 **수십만 배** 느리다. 그래서 I/O를 "기다리는" 방식이 비효율적인 것. (#⭐⭐⭐⭐⭐⭐)

---

# '모듈 시스템' 과 관련해서

```
- node.js 에서 '모듈 시스템' 을 도입 -> 파일 시스템, 네트워크 등의 '내장 모듈' 을 사용할 수 있게 됨
- 모듈 시스템이 없어도 내장 모듈을 쓸 수 있었다는데? ❓❓❓❓❓❓❓❓❓
- 더 쉽게 쓸 수 있게 된거지?
```

```
1) 2009년 전: 모듈 시스템 자체가 없었음
   → 브라우저는 <script> 태그, 전역 변수로 공유

2) 2009년: CommonJS 명세 등장
   → "JS를 브라우저 밖에서도 쓰자"는 목표로 만든 표준안

3) 채택 여부
   → Node.js: 채택 O (require/module.exports 구현)
   → 브라우저: 채택 X (동기 방식이 네트워크 환경에 안 맞아서)
    (# 동기 일 때, 해당 파일을 import 할 때, '대기' 하기 때문에)

```

![alt text](image-2.png)

# 그러면, 이렇게 NODE.JS 가 등장했다는 건, '비동기 I/O' 처리할 수 있는 서버가 있다는 거 아닌가?

## 5. 브라우저 vs Node.js 차이

### 핵심 차이: 시스템 리소스 접근

| 구분          | 브라우저 JS     | Node.js                      |
| ------------- | --------------- | ---------------------------- |
| 파일 시스템   | X (보안상 차단) | O (`fs` 모듈)                |
| 네트워크 서버 | X               | O (`http` 모듈)              |
| OS 접근       | X               | O (`os`, `child_process` 등) |
| 용도          | 웹페이지 조작   | 서버, CLI 도구, 빌드 도구 등 |

### 브라우저가 제한하는 이유

보안 때문. 웹사이트가 사용자 컴퓨터의 파일을 마음대로 읽고 쓸 수 있으면 위험하다.

### Node.js가 가능한 이유

Node.js는 사용자가 직접 실행하는 프로그램이므로, 시스템 접근 권한을 가질 수 있다.

```javascript
// Node.js에서만 가능
const fs = require("fs");
const http = require("http");

// 파일 읽기
fs.readFile("data.txt", (err, data) => {
  console.log(data);
});

// 서버 만들기
http
  .createServer((req, res) => {
    res.end("Hello World");
  })
  .listen(3000);
```

---

## 6. React와 Node.js의 관계

### React는 어디서 실행되나?

**React 자체는 브라우저에서 실행된다.**

### 그런데 왜 개발할 때 Node.js가 필요한가?

개발 도구들이 Node.js 위에서 돌아가기 때문:

| 도구         | 역할                                   | Node.js 필요 |
| ------------ | -------------------------------------- | ------------ |
| npm/yarn     | 패키지 관리                            | O            |
| Webpack/Vite | 번들링 (여러 파일을 하나로)            | O            |
| Babel        | 트랜스파일링 (최신 문법 → 구버전 변환) | O            |
| ESLint       | 코드 검사                              | O            |

### 흐름

```
[개발 시]
React 코드 작성 → Node.js 기반 빌드 도구 → 번들된 JS 파일

[배포 후]
브라우저가 번들된 JS 파일 실행 → React 앱 동작
```

즉, **개발 환경에서 Node.js가 필요**하고, **실행 환경(브라우저)에서는 필요 없다.**
